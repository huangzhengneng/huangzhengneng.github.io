<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JackHuang&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-21T03:11:22.411Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jack Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jdk1.8#HashMap源码分析</title>
    <link href="http://yoursite.com/2019/08/09/jdk1-8-HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/08/09/jdk1-8-HashMap源码分析/</id>
    <published>2019-08-09T09:52:36.000Z</published>
    <updated>2019-11-21T03:11:22.411Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/hashmap_cover.jpeg" alt="hashmap"></p><hr><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>HashMap</strong>是我们经常使用的一个key-value类型的集合类，它内部的数据结构就是散列表，散列表具有非常高的查询效率，它的增、删、查的时间复杂度都是O(1)，在jdk1.7中，hashmap解决散列冲突是用的链表法，这种方法存在的问题就是极端情况下，即所有存的值都被散列到同一个下标处，hashmap就会退化为链表，因此时间复杂度会大打折扣，为了避免这个问题，jdk1.8引入了红黑树，即使极端情况发生，查询效率也是O(logn)，红黑树提供了效率的保证。<br>在jdk1.8中hashmap的结构图是这样的(图片来自网络)：<img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/hashmap_img.png" alt="hashmap_data_img"></p><blockquote><p>本文基于jdk版本为：jdk1.8.0_161</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>hashmap有四个构造方法如下：</p><figure class="highlight java"><figcaption><span>HashMap.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>loadFactor</strong>：负载系数，即扩容阈值，当前表内元素超过 表容量*loadFactor 之后，就会触发扩容</li><li><strong>threshold</strong>：扩容阈值，当表内元素数量超过该值时，触发扩容</li></ul><p>四个构造方法最常用的是无参构造方法，可以看到源码注释表示其它属性全都是默认，加载因子也是默认的0.75：<br><figure class="highlight java"><figcaption><span>HashMap.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><br>接下来是传入initialCapacity的以及传入initialCapacity、loadFactor两个值的构造方法，关键代码如下：<br><figure class="highlight java"><figcaption><span>HashMap.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY) </span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> * 这里通过无符号右移1、2、4、8、16位并且进行或运算，会得到大于输入值cap最近的2的指数值，可以自行去验证一下，比如输入13，得到16，输入16，得到16，输入17得到32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这一段是对构造方法传入的初始容量做校验，从源码注释来看，初始容量必须是2的指数并且小于等2^30，为什么必须是2的指数？为了元素能均匀分布在数组槽中，具体为什么后面hash()再解释。最大值为什么是2^30不是2^31？因为int最高位是符号位，不能左移到符号位。</p><p>接下来看输入map的构造函数，调用了putMapEntries方法：<br><figure class="highlight java"><figcaption><span>HashMap.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.putAll and Map constructor</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict false when initially constructing this map, else</span></span><br><span class="line"><span class="comment"> * true (relayed to method afterNodeInsertion).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                        (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从源码来看，初始化时，会进入if(table == null) 分支，也会调用tableSizeFor方法，给threshold赋值，然后遍历传入的map，依次存入当前的map，里面涉及的resize和putVal方法后面介绍。</p><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>构造方法分析完了，接下来分析put方法<br><figure class="highlight java"><figcaption><span>HashMap.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> 如果为true，已经存在的元素，不会覆盖原值，默认为false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> 如果为false，表示是正在创建hashMap，true表示创建之后的put操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回原值，如果不存在返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length; <span class="comment">// 如果数组为空，调用resize方法进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// 对应槽中为空，直接插入新元素</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p; <span class="comment">// 槽中首个元素命中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 槽中首个元素没有命中，并且槽中是树形结构</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 槽中首个元素没有命中，并且槽中是链式结构</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123; <span class="comment">// 槽中首个元素next为空，直接加在next位置</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash); <span class="comment">// 槽内节点数量达到树化阈值，进行树化</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 命中p.next</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>) <span class="comment">// 如果已经存在了并且onlyIfAbsent为false或者旧值为空，覆盖value</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e); <span class="comment">// 回调</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount; <span class="comment">// 修改次数增加</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize(); <span class="comment">// 如果size达到阈值-1，进行扩容</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>put中最先涉及到的方法是hash(key)，并且在put的时候，会计算目标元素应该存储的槽index，计算方法是(n - 1) &amp; hash(key)，n是槽数组的长度，先看(n - 1) &amp; hash(key)公式的来头：</p><ol><li>如果key为null，hash(key)返回0，那么(n - 1) &amp; 0 = 0</li><li>如果key不为null，hash(key)结果是(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</li></ol><p>使用的是将key的hashCode值无符号右移16位，然后再与key的hashCode值做异或操作，这里随机假设表容量为16，key.hashCode()的二进制值 = 1001 0101 1111 0011 1100 1010 0101 0111, 异或是指相同为0，不同则为1</p><p>该运算过程如下:<br>h                          :   1001 0101 1111 0011 1100 1010 0101 0111    :   2515782231<br>h &gt;&gt;&gt; 16                   :   0000 0000 0000 0000 1001 0101 1111 0011    :   38387<br>h ^ (h &gt;&gt;&gt; 16)             :   1001 0101 1111 0011 0101 1111 1010 0100    :   2515754916<br>n - 1                      :   0000 0000 0000 0000 0000 0000 0000 1111    :   15<br>(n - 1) &amp; (h ^ (h &gt;&gt;&gt; 16)) :   0000 0000 0000 0000 0000 0000 0000 0100    :   8</p><p>得出最后对应的index为8，即下标为8的槽。<br>这里有个疑问：为什么要进行无符号右移16位？答案是如果两个key的hashCode低位相同但是高位不同，在容量不是特别大的情况下(即高位都为0的情况)得到的index会一样，这么进行扰动可以进一步降低冲突的概率，毕竟大部分情况下，容量不大。</p><p>接着看putVal方法，如果数组为空，会调用resize方法，那么什么时候会为空？从上面的构造方法分析可以看出来，创建hashmap对象没有执行put操作，都会是空；传入map的构造函数也会调用put方法，因此会简介赋值。来看看resize方法：<br><figure class="highlight java"><figcaption><span>HashMap.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">// 当前表不为空，需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab; <span class="comment">// 如果当前的数组大小已经达到最大值，直接返回，不再扩容</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 如果扩容后的数组大小没有超过最大值，新数组的容量扩大为当前的两倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr; <span class="comment">// 当前容量为空，但是阈值不为0，将新数组的容量设置为阈值大小，就是数组为空对象的情况</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// 都为0就赋值默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123; <span class="comment">// 数组为空对象的情况,设置阈值</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab; <span class="comment">// 创建新数组</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123; <span class="comment">// 如果旧数组不为空，迁移数据到新数组内</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>; <span class="comment">// 置空释放</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) <span class="comment">// 这个槽只有一个元素，直接赋值</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">// 会重新计算下标</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 树形结构调用treeNode.split方法重新赋值，下面再具体分析</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表结构并且不止一个元素</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// (e.hash &amp; oldCap) == 0表示 扩容之后计算得到的跟扩容之前是同一个槽，不等于0表示不是同一个槽，可以举例去计算一下</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123; <span class="comment">// 扩容前后下标没有发生变化的槽内链表，即赋值</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;<span class="comment">// 扩容前后下标发生变化的槽内链表，赋值到旧下标+旧数组长度的下标处</span></span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继续看putVal方法，如果命中的槽位内容为空，直接新建节点赋值到当前槽内，否则，进入槽内判断；如果命中了槽内第一个节点，进入赋值阶段；如果没有名中首个节点，分链表和树两种情况。先看链表：<br><figure class="highlight java"><figcaption><span>HashMap.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            treeifyBin(tab, hash); <span class="comment">// 槽内节点数量达到树化阈值，改造结构为红黑树</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 这里表示找到了已经存在的元素，跳出循环进入赋值操作</span></span><br><span class="line">    p = e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 树化链表</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize(); <span class="comment">// 如果数组为空，或者数组内容数量小于最小树化阈值(64)，先进行扩容重新排列数据来降低冲突率</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123; <span class="comment">// 找到槽内头节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>); <span class="comment">// 通过Node节点构建TreeNode节点</span></span><br><span class="line">            <span class="comment">// 这里是根据链表得到红黑树的前序遍历序列(红黑树是自平衡的二叉查找树)</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p; <span class="comment">// 树的根节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>) <span class="comment">// 将树的根节点赋值到数组中</span></span><br><span class="line">            hd.treeify(tab); <span class="comment">// 树化真正实现，根据前序遍历生成红黑树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里涉及到了 <strong>红黑树</strong> ,如果对红黑树不熟悉，可以去看我<a href="http://jackhuang.online/2019/08/09/red-black-tree%E7%AE%80%E4%BB%8B/" target="_blank" rel="noopener">这篇文章</a>，上面的链表添加完新节点之后，会判断链表长度是否达到树化阈值，如果达到了，就会进入treeifyBin方法，这个方法里又再一次做了判断，如果map中数组的长度低于最小树化长度(即MIN_TREEIFY_CAPACITY值=64)，会直接进行扩容，而不是树化，扩容会再次计算各个元素所处的槽位置，降低冲突概率，虽然红黑树效率高，但是如果元素数量比较少，红黑树的效率优势不明显，徒劳增加转换操作。接下来看treeify方法:</p><figure class="highlight java"><figcaption><span>HashMap.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next; <span class="comment">// 前面有提到next的赋值，next是指x节点在树的前序遍历序列中的后继节点</span></span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">// 设置根节点的判断</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>; <span class="comment">// 设置为黑色</span></span><br><span class="line">            root = x; <span class="comment">// 设置当前调用这个方法的treeNode对象为根节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 根节点设置好了，第一次进入else的x = 前序遍历中的第二个节点，之后的循环就一直往后走</span></span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h) <span class="comment">// 当前节点小于root节点的哈希值，应该插入到root节点的左子树</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) <span class="comment">// 当前节点大于root节点的哈希值,应该插入到root节点的右子树</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                            (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 这个if的意思是当前节点的key类型没有实现comparable接口，或者实现了该接口，但是root节点的key为空或没有实现comparable接口</span></span><br><span class="line">                    <span class="comment">// 意思就是当要插入的元素key的hashCode和root-key的hashCode相等或者是不可比较的类</span></span><br><span class="line">                    <span class="comment">// tieBreakOrder方法根据System.identityHashCode()方法返回值判断元素的key比较结果，identityHashCode方法返回的是Object.hashCode方法返回值，如果对象复写了hashCode方法，System.identityHashCode()和obj.hashCode返回值就不一样,为了处理hashCode冲突的情况</span></span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    root = balanceInsertion(root, x);<span class="comment">// 插入元素之后，进行平衡调整</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    moveRootToFront(tab, root); <span class="comment">// 把根节点移到槽中第一个位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>treeify方法就是根据树的前序遍历序列生成红黑树的过程，大体原理相当于红黑树插入元素的过程，因此插入数据之后会进行平衡调整，来看看balanceInsertion方法：<br><figure class="highlight java"><figcaption><span>HashMap.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// root是当前的根节点，x是插入的节点，即关注节点</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    x.red = <span class="keyword">true</span>; <span class="comment">// 插入的节点必须是红色，红黑树的定义里有</span></span><br><span class="line">    <span class="comment">// xp表示x节点的父节点，xpp是祖父节点，xppl是祖父节点的左子节点，xppr是祖父节点的右子节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123; <span class="comment">// xp = null，表示当前插入的节点位置刚好是根节点，直接设置为黑色，返回；  命中红黑树插入节点时的特殊情况第二种</span></span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 命中红黑树插入节点时的特殊情况第一种，即插入节点的父节点是黑色，并且父节点不是跟节点，那什么都不用做，仍然符合红黑树的定义</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123; <span class="comment">// 如果x节点的父节点是其祖父节点的左子节点</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123; <span class="comment">// 如果x节点的叔叔节点是红色的，命中红黑树插入操作平衡调整规则的case1，父节点和叔叔节点都设置为黑色，祖父节点设置为红色，关注节点变成祖父节点</span></span><br><span class="line">                xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123; <span class="comment">// 如果关注节点是其父节点的右子节点，命中红黑树插入操作平衡调整规则的case2，关注节点变成a的父节点b，围绕新的关注节点b左旋</span></span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123; <span class="comment">// 如果关注节点是其父节点的左子节点，命中红黑树插入操作平衡调整规则的case3, 先交换x的父节点和祖父节点的颜色，再围绕祖父节点右旋(case3里是先围绕祖父节点右旋，再交换x的父节点和兄弟节点，跟这里结果是一样的，顺序不一样罢了)</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// 这里是上面的反例，方向不同罢了，原理类似，不多说了</span></span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>balanceInsertion方法就是<a href="http://jackhuang.online/2019/08/09/red-black-tree%E7%AE%80%E4%BB%8B/" target="_blank" rel="noopener">红黑树</a>中对插入操作的平衡调整策略代码实现，期间调用到了左旋、右旋代码，也来看一看：<br><figure class="highlight java"><figcaption><span>HashMap.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p是关注节点，针对该节点进行左旋</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pp表示p节点的父节点，r表示p节点的右子节点，rl表示p的右子节点的左子节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123; <span class="comment">// 如果p的右子节点不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">            rl.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>) <span class="comment">// 如果p就是根节点了，直接把r设置为根节点，并且设置为黑色</span></span><br><span class="line">            (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p) <span class="comment">// 如果p不是根节点</span></span><br><span class="line">            pp.left = r; <span class="comment">// p是其父节点的左子节点, 把p的父节点的左子节点指针指向r</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = r; <span class="comment">// p是其父节点的右子节点, 把p的父节点的右子节点指针指向r</span></span><br><span class="line">        r.left = p; <span class="comment">// p旋转到r的左子节点处</span></span><br><span class="line">        p.parent = r; <span class="comment">// p的父节点指针指向r</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pp表示p节点的父节点，l表示p节点的左子节点，lr表示p的左子节点的右子节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;<span class="comment">// 如果p的左子节点不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line">            lr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)<span class="comment">// 如果p就是根节点了，直接把l设置为根节点，并且设置为黑色</span></span><br><span class="line">            (root = l).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)<span class="comment">// 如果p不是根节点</span></span><br><span class="line">            pp.right = l; <span class="comment">// p是其父节点的右子节点, 把p的父节点的右子节点指针指向l</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.left = l;<span class="comment">// p是其父节点的左子节点, 把p的父节点的左子节点指针指向l</span></span><br><span class="line">        l.right = p; <span class="comment">// p旋转到r的右子节点处</span></span><br><span class="line">        p.parent = l;<span class="comment">// p的父节点指针指向l</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>左旋、右旋照着图看很容易理解，到这里由链表结构生成红黑树结构就分析完了，接着看putVal方法：<br><figure class="highlight java"><figcaption><span>HashMap.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>; <span class="comment">// 赋值根节点，如果当前parent不为空，调用root()方法往上遍历parent，找出root节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)<span class="comment">// 当前节点小于root节点的哈希值，应该插入到root节点的左子</span></span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)<span class="comment">// 当前节点大于root节点的哈希值,应该插入到root节点的右子树</span></span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p; <span class="comment">// 如果要插入的元素根据key查找已经存在树中了，直接返回</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                    (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123; <span class="comment">// 哨兵优化</span></span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                <span class="comment">// 遇到key.hashCode冲突的节点，分别从其左、右子树中去查找，找到就直接返回</span></span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 同上面分析树化一样，hashCode冲突时的处理</span></span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到了插入的节点位置</span></span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            <span class="comment">// 生成新节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="comment">// 插入节点</span></span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x; <span class="comment">// 赋值父节点的next</span></span><br><span class="line">            <span class="comment">// 赋值prev和parent，二叉查找树的前序遍历中prev和parent相同</span></span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>) <span class="comment">// 这里指要插入的节点是一颗子树，设置一下next的prev指针</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            <span class="comment">// 平衡调整以及移动root节点到槽中第一个位置</span></span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>treeNode.putTreeVal方法实现跟treeify方法大体类似，不多做解释了。继续看putVal方法：<br><figure class="highlight java"><figcaption><span>HashMap.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// 这里表示要设置的元素值已经存在于map当中</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>) <span class="comment">// 如果onlyIfAbsent为false或者旧值为空，则覆盖旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e); <span class="comment">// callback</span></span><br><span class="line">            <span class="keyword">return</span> oldValue; <span class="comment">// 返回旧值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 走到这里说明设置的键值对在map中没有，是新增的</span></span><br><span class="line">    ++modCount; <span class="comment">// 修改次数增加</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize(); <span class="comment">// 按需进行扩容</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里hashMap#put方法就分析完了，因为涉及到红黑树，还是很复杂的。put方法会返回key对应位置元素的原值，如果没有原值，返回null。</p><h3 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h3><p>接下来分析get方法，hashmap有一个get方法，还有一个getOrDefault方法：<br><figure class="highlight java"><figcaption><span>HashMap.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>两者都是调用的getNode(hash(key), key)方法，不同的是getOrDefault方法如果没有找到元素会返回默认值。先看看这两个方法：<br><figure class="highlight java"><figcaption><span>HashMap.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// 命中槽内首个元素，直接返回</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 树形结构，getTreeNode</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 链式结构，遍历链表查找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里主要分3步：</p><ol><li>通过 (n - 1) &amp; hash(key) 计算要查找的元素所处的数组下标</li><li>如果是数组槽的第一个元素，直接返回</li><li>如果不是第一个元素，并且该槽不止一个元素，分两种情况，如果是树形结构，调用getTreeNode获取，如果不是，遍历链表查询</li></ol><p>第一步put时分析过了，后两步中除了getTreeNode其它都很简单，这里来看一下getTreeNode方法：</p><figure class="highlight java"><figcaption><span>HashMap.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找到root节点，调用root节点的find方法</span></span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>; <span class="comment">// root节点</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// ph表示p节点的hash值，dir表示方向(即左子树/右子树),pk表示p节点的key</span></span><br><span class="line">        <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h) <span class="comment">// 要查找的节点hash值小于当前节点，往左子树继续循环</span></span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)<span class="comment">// 要查找的节点hash值大于当前节点，往右子树继续循环</span></span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;<span class="comment">// 找到了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>) <span class="comment">// 左子节点为空，往右子树继续循环</span></span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)<span class="comment">// 右子节点为空，往左子树继续循环</span></span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                    (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                    (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// hash值冲突情况，比较两者的key</span></span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>) <span class="comment">// key的类型不能比较(没有实现comparable接口), 继续调用pr.find查找</span></span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getTreeNode方法通过root节点调用find方法查找节点，find方法基本就是二叉查找树的查找过程，很简单，不多解释了。</p><p>到这里get方法也分析完了，相对于put方法要简单很多，红黑树的get方法也很简单，就是二叉查找树的查找过程，不是很复杂。</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>接下来分析remove方法，hashMap有两个remove方法：remove(key) 和 remove(key, value):<br><figure class="highlight java"><figcaption><span>HashMap.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两者都调用了removeNode方法，一个传入了value，一个没有传入value，区别就是传入value的方法，如果根据key找到了元素，但是value不一致，不会执行删除操作；来看一下removeNode的实现：<br><figure class="highlight java"><figcaption><span>HashMap.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 这一段跟get方法一直，删除会先查找到对应元素</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                            (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除操作</span></span><br><span class="line">        <span class="comment">// matchValue为false或者matchValue为true时传入的value和查找到的value相等时，执行删除</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 树形结构，调用removeTreeNode</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">// 链式结构，并且是槽内第一个元素，直接把next元素覆盖掉node元素，相当于删除链表头结点</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 链式结构，但不是第一个元素，删除链表中的节点</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到，返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>removeNode方法前半部分和get方法一致，先查找对应的节点，找到之后，按三种情况分别执行删除，上面注释已经很清楚了，这里再来看看treeNode.removeTreeNode方法：</p><figure class="highlight java"><figcaption><span>HashMap.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// map为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 计算出index</span></span><br><span class="line">    <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">    TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">    <span class="comment">// 下面这个if-else操作是从当前红黑树的前序遍历序列中删除对应的节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>) <span class="comment">// 当前节点是root节点, 赋值槽内首个节点以及first，first用来降级为链表</span></span><br><span class="line">        tab[index] = first = succ;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 移除当前节点</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">    <span class="comment">// 不为空表示不是尾节点，赋值prev指针为当前节点的prev节点</span></span><br><span class="line">    <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    <span class="comment">// first为空，那succ也是null，命中红黑树删除调整规则中第一步的case1，不需要进行第二步调整</span></span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找出root节点，为什么做这个判断？每次put的时候都会调用moveRootToFront方法移到槽内头部，这里从头部获取到的root节点为什么有可能parent不为空？暂时还没看出来</span></span><br><span class="line">    <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">        root = root.root();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ||</span><br><span class="line">        (rl = root.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// root,root.right,root.left,root.left.right,root.right.left,root.right.right</span></span><br><span class="line">        <span class="comment">// 经过这四个判断，这棵红黑树最多六个节点</span></span><br><span class="line">        <span class="comment">// 降级为链表，也就不用管树的调整了，直接利用前序遍历列表降级为链表</span></span><br><span class="line">        tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// replacement表示第一步调整之后的关注节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">    <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123; <span class="comment">// 命中红黑树删除调整规则中第一步的case2或者case3</span></span><br><span class="line">        <span class="comment">// s是右子节点，这一步是找到右子树中最小的节点，即当前节点的后继节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">        <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">            s = sl;</span><br><span class="line">        <span class="comment">// 交换当前节点和后继节点的颜色</span></span><br><span class="line">        <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">        TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// 这里表示s就是p的右子节点，并且s没有左子节点了，命中红黑树删除调整规则中第一步的case2</span></span><br><span class="line">            <span class="comment">// 将后继节点替换到当前节点的位置</span></span><br><span class="line">            p.parent = s;</span><br><span class="line">            s.right = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 命中红黑树删除调整规则中第一步的case3，</span></span><br><span class="line">            TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">            <span class="comment">// p.parent = sp表示把后继节点移到关注节点的位置</span></span><br><span class="line">            <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将关注节点p赋值给后继节点s(即赋值颜色等)</span></span><br><span class="line">                <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                    sp.left = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sp.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 关注节点的右子节点不为空，连接到后继节点s的右子节点处</span></span><br><span class="line">                pr.parent = s;</span><br><span class="line">        &#125;</span><br><span class="line">        p.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">            sr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">            pl.parent = s;</span><br><span class="line">        <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">            root = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = s;</span><br><span class="line">        <span class="comment">// 确定下一步的关注节点</span></span><br><span class="line">        <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">            replacement = sr;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定下一步的关注节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        replacement = p;</span><br><span class="line">    <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">        <span class="comment">// 关注节点不是当前节点，说明</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = replacement;</span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果删除的是红色节点，可以直接删除，不需要二次调整，否则进行二次调整balanceDeletion</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// 这里是真正删除节点的操作，上面都是带着p节点在操作调整等</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        p.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                pp.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (movable)</span><br><span class="line">        moveRootToFront(tab, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>removeTreeNode方法实现特别复杂，需要配合<a href="http://jackhuang.online/2019/08/09/red-black-tree%E7%AE%80%E4%BB%8B/" target="_blank" rel="noopener">红黑树的删除规则图</a>一起看，二次调整的方法balanceDeletion实现如下：</p><figure class="highlight java"><figcaption><span>HashMap.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// xp表示关注节点x的父节点，xpl、xpr分别表示父节点的左右子节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</span><br><span class="line">        <span class="comment">// 如果x节点为空或者x节点是根节点，不需要二次调整，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span> || x == root)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 如果x的父节点为空，直接设置x节点为黑色</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果关注节点x是红色，设置为黑色</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果x是其父节点的左子节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123;</span><br><span class="line">            <span class="comment">// 如果其兄弟节点是红色，命中红黑树删除调整规则第二步的case1</span></span><br><span class="line">            <span class="keyword">if</span> ((xpr = xp.right) != <span class="keyword">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class="line">                xpr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">true</span>;</span><br><span class="line">                root = rotateLeft(root, xp); <span class="comment">// 围绕关注节点a的父节点左旋</span></span><br><span class="line">                xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (xpr == <span class="keyword">null</span>)</span><br><span class="line">                x = xp;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">                <span class="comment">// 命中红黑树删除调整规则第二步的case2，设置关注节点x的兄弟节点为红色，关注节点变成其父节点</span></span><br><span class="line">                <span class="keyword">if</span> ((sr == <span class="keyword">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">                    (sl == <span class="keyword">null</span> || !sl.red)) &#123;</span><br><span class="line">                    xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                    x = xp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sr == <span class="keyword">null</span> || !sr.red) &#123;</span><br><span class="line">                        <span class="comment">// 命中红黑树删除调整规则第二步的case3</span></span><br><span class="line">                        <span class="keyword">if</span> (sl != <span class="keyword">null</span>)</span><br><span class="line">                            sl.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">// 围绕关注节点兄弟节点右旋</span></span><br><span class="line">                        root = rotateRight(root, xpr);</span><br><span class="line">                        xpr = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                            <span class="keyword">null</span> : xp.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 关注节点不变，命中红黑树删除调整规则第二步的case4</span></span><br><span class="line">                    <span class="keyword">if</span> (xpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 将关注节点x的兄弟节点的颜色设置为其父节点的颜色</span></span><br><span class="line">                        xpr.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                        <span class="keyword">if</span> ((sr = xpr.right) != <span class="keyword">null</span>)</span><br><span class="line">                            sr.red = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="comment">// 围绕关注节点x的父节点左旋</span></span><br><span class="line">                        root = rotateLeft(root, xp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 这里是if里的对称面，原理类似，不再解释</span></span><br><span class="line">            <span class="keyword">if</span> (xpl != <span class="keyword">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">                xpl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">true</span>;</span><br><span class="line">                root = rotateRight(root, xp);</span><br><span class="line">                xpl = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (xpl == <span class="keyword">null</span>)</span><br><span class="line">                x = xp;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                <span class="keyword">if</span> ((sl == <span class="keyword">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">                    (sr == <span class="keyword">null</span> || !sr.red)) &#123;</span><br><span class="line">                    xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                    x = xp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sl == <span class="keyword">null</span> || !sl.red) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                            sr.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpl);</span><br><span class="line">                        xpl = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                            <span class="keyword">null</span> : xp.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpl.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                        <span class="keyword">if</span> ((sl = xpl.left) != <span class="keyword">null</span>)</span><br><span class="line">                            sl.red = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        root = rotateRight(root, xp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>balanceDeletion的实现就是红黑树删除操作的第二步调整，调整红黑树用以符合红黑树的第四条特征，即红色节点的两个子节点必须是黑色。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，hashmap主要操作已经分析完了，由于加入了红黑树而变得复杂起来，熟悉了红黑树也就熟悉了hashmap的一半，红黑树是极端情况下hashmap查询效率的保证。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/huangzhengneng/ImageFactory/raw/master/blog/hashmap_cover.jpeg&quot; alt=&quot;hashmap&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
      <category term="map" scheme="http://yoursite.com/categories/java/map/"/>
    
    
      <category term="source analysis" scheme="http://yoursite.com/tags/source-analysis/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>red-black-tree简介</title>
    <link href="http://yoursite.com/2019/08/09/red-black-tree%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2019/08/09/red-black-tree简介/</id>
    <published>2019-08-09T05:12:10.000Z</published>
    <updated>2019-11-21T03:11:22.411Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/red_black_tree_cover.jpg" alt="red-black-tree"></p><hr><a id="more"></a><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><strong>红黑树</strong>是一种自平衡的二叉查找树，1972年由Rudolf Bayer发明的，当时叫做平衡二叉B树，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。</p><p><strong>红黑树</strong> 和 <strong>AVL</strong> 树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。原理虽然很复杂，但它提供了时间上的保证，即最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(logn)时间内做查找，插入和删除，n指树中节点的数目。</p><p>红黑树特殊是因为其有几条特性需要遵守，特性如下：</p><ol><li>节点是红色或者黑色</li><li>根节点只能是黑色</li><li>每个叶子节点都是黑色的空节点(值为null)</li><li>每个红色节点的两个子节点都是黑色</li><li>从任意节点到其每个叶子节点的所有路径都包含相同数量的黑色节点</li></ol><p>红黑树示例图：<br><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/red_black_tree_exp.png" alt="red-black-tree-exp"></p><p>当插入/删除节点时，如果破坏了红黑树的规则定义，就需要进行自我调整，调整策略有两种：<strong>左旋</strong>、<strong>右旋</strong>，即“围绕某个节点的左旋”和“围绕某个节点的右旋”, 左旋、右旋的示例如下：</p><p><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/red_black_tree_rotation.png" alt="red-black-tree-rotation"></p><p>那什么时候需要进行调整呢？分操作来讲</p><ol><li>插入操作</li></ol><p>红黑树规定，插入的节点必须是红色的，而且，二叉查找树中新插入的节点都是放在叶子节点上。</p><ul><li>如果插入节点的父节点是黑色的，那什么都不用做，它仍然满足红黑树的定义</li><li>如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了</li></ul><p>除了上面两种特殊情况以外，其它所有的插入操作都会破坏红黑树的定义，如果红黑树的插入操作导致平衡被打破，会有三种情况，这里假设插入的节点是a，并把a作为关注节点：</p><p><strong>case 1</strong>：如果关注节点是a，它的叔叔节点d是红色，就依次执行下面的操作：</p><ul><li>将关注节点a的父节点b、叔叔节点d的颜色都设置为黑色</li><li>将关注节点a的祖父节点c的颜色设置为红色</li><li>关注节点变成a的祖父节点c</li><li>跳到 case2 或者 case3</li></ul><p>如图：<img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/red_black_tree_insert_case_1.png" alt="red-black-tree-insert-case-1"></p><p><strong>case 2</strong>：如果关注节点是a，它的叔叔节点d是黑色，关注节点a的是其父节点b的右子节点，依次执行下面的操作：</p><ul><li>关注节点变成a的父节点b</li><li>围绕新的关注节点b左旋</li><li>跳到case3</li></ul><p>如图：<img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/red_black_tree_insert_case_2.png" alt="red-black-tree-insert-case-2"></p><p><strong>case 3</strong>：如果关注节点是a，它的叔叔节点d是黑色，关注节点a的是其父节点b的左子节点，依次执行下面的操作：</p><ul><li>围绕关注节点a的祖父节点c右旋</li><li>将关注节点a的父节点b、兄弟节点c颜色互换</li><li>调整结束</li></ul><p>如图：<img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/red_black_tree_insert_case_3.png" alt="red-black-tree-insert-case-3"></p><ol start="2"><li>删除操作</li></ol><p>删除操作的平衡调整分为两步，第一步是针对删除节点初步调整，保证在一个节点删除后，仍然满足最后一条定义的要求。第二步是针对关注节点进行第二次调整，让它满足第四条定义。</p><blockquote><p>接下来的分析里，如果一个节点既可以是红色，也可以是黑色，在图里表现出来一半红色一半黑色的点，如果一个节点是“红-黑”或者“黑-黑”，在图里表现出来一个小黑点在左上角。</p></blockquote><p>2.1 先看第一步的三种情况的调整过程：</p><p><strong>case 1</strong>：如果要删除的节点是a，它只有一个子节点b，就依次执行下面的操作：</p><ul><li>删除节点a，并且把节点b替换到节点a的位置，这一部分操作跟普通的二叉查找树的删除操作一样</li><li>节点a只能是黑色，节点b也只能是红色，其它情况均不符合红黑树的定义，这种情况下，把节点b改为黑色</li><li>调整结束，不需要进行第二次调整</li></ul><p>如图：<img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/red_black_tree_delete_step_1_case_1.png" alt="red-black-tree-delete-step-1-case-1"></p><p><strong>case 2</strong>：如果要删除的节点a有两个非空子节点，并且它的后继结点就是节点a的右子节点c，就依次执行下面的操作：</p><ul><li>如果节点a的后继结点就是右子节点c，那右子节点c肯定没有左子树，把节点a删除，并且将节点c替换到节点a的位置。这一部分的操作跟普通的二叉查找树的删除操作一样</li><li>然后把节点c的颜色设置为节点a的颜色</li><li>如果节点c是黑色，为了不违反红黑树最后一条定义，我们给节点c的右子节点d多加一个黑色，这个时候节点d就成了“红-黑”或者“黑-黑”</li><li>这个时候，关注节点变成了节点d，第二步的调整操作就会针对关注节点来做</li></ul><p>如图：<img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/red_black_tree_delete_step_1_case_2.png" alt="red-black-tree-delete-step-1-case-2"></p><p><strong>case 3</strong>：如果要删除的是节点a，它有两个非空子节点，并且节点a的后继节点不是右子节点，就依次执行下面的操作：</p><ul><li>找到后继节点d，并将它删除，删除后继节点的过程参照case1</li><li>将节点a替换成后继节点d</li><li>把节点d的颜色设置为a的颜色</li><li>如果节点d是黑色，为了不违反红黑树最后一条定义，我给节点d的右子节点c多加一个黑色，c变成了“红-黑”或者“黑-黑”</li><li>这个时候，关注节点变成了节点c，第二步的调整操作会针对关注节点来做</li></ul><p>如图：<img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/red_black_tree_delete_step_1_case_3.png" alt="red-black-tree-delete-step-1-case-3"></p><p>2.2 针对关注节点进行第二次调整</p><p>经过初步调整后，关注节点变成了“红-黑”或者“黑-黑”，针对这个节点，再分四种情况，二次调整是为了满足红黑树第四条定义。</p><p><strong>case 1</strong>：如果关注节点是a，它的兄弟节点c是红色的，就依次执行下面的操作：</p><ul><li>围绕关注节点a的父节点b左旋</li><li>关注节点a的父节点b和祖父节点c交换颜色</li><li>关注节点不变</li><li>继续从四种情况中选择合适的规则来调整</li></ul><p>如图：<img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/red_black_tree_delete_step_2_case_1.png" alt="red-black-tree-delete-step-2-case-1"></p><p><strong>case 2</strong>：如果关注节点是a，它的兄弟节点c是黑色的，并且节点c的左右子节点d、e都是黑色的，就依次进行下面的操作：</p><ul><li>将关注节点a的兄弟节点c的颜色变成红色</li><li>从关注节点a中去掉一个黑色，这个时候节点a就是单纯的红色或者黑色</li><li>给关注节点a的父节点b添加一个黑色，这个时候b就变成了“红-黑”或者“黑-黑”</li><li>关注节点变成a的父节点b</li><li>继续从四种情况中选择合适的规则来调整</li></ul><p>如图：<img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/red_black_tree_delete_step_2_case_2.png" alt="red-black-tree-delete-step-2-case-2"></p><p><strong>case 3</strong>：如果关注节点是a，它的兄弟节点c是黑色的，c的左子节点d是红色，c的右子节点e是黑色，就依次进行下面的操作：</p><ul><li>围绕关注节点a的兄弟节点c右旋</li><li>节点c和节点d交换颜色</li><li>关注节点不变</li><li>跳转到case4，继续调整</li></ul><p>如图：<img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/red_black_tree_delete_step_2_case_3.png" alt="red-black-tree-delete-step-2-case-3"></p><p><strong>case 4</strong>：如果关注节点a的兄弟节点c是黑色的，并且c的右子节点是红色的，就依次进行下面的操作：</p><ul><li>围绕关注节点a的父节点b左旋</li><li>将关注节点a的兄弟节点c的颜色，跟关注节点a的父节点b设置成一样的颜色</li><li>将关注节点a的父节点b的颜色设置为黑色</li><li>从关注节点a中去掉一个黑色，节点a变成单纯的红色或者黑色</li><li>将关注节点a的叔叔节点e设置为黑色</li><li>调整结束</li></ul><p>如图：<img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/red_black_tree_delete_step_2_case_4.png" alt="red-black-tree-delete-step-2-case-4"></p><p>红黑树的平衡调整策略比较复杂，不需要试图去记住他们，看懂整个过程就行了，一般不会让写实现，知道原理就行了。</p><p>总结一下调整过程的几个要素：</p><ol><li>把红黑树的平衡调整的过程比作魔方复原，不要过于深究这个算法的正确性</li></ol><blockquote><p>只需要明白按照固定的操作步骤，保持插入、删除的过程不破坏平衡树的定义</p></blockquote><ol start="2"><li>找准关注节点，不要搞丢、搞错关注节点</li></ol><blockquote><p>每种操作规则都是针对关注节点来做的，弄对了关注节点最重要，调整过程中，关注节点不停地改变</p></blockquote><ol start="3"><li>插入操作的平衡调整比较简单，删除操作的比较复杂。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/huangzhengneng/ImageFactory/raw/master/blog/red_black_tree_cover.jpg&quot; alt=&quot;red-black-tree&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="data-structure" scheme="http://yoursite.com/categories/data-structure/"/>
    
    
      <category term="data-structure" scheme="http://yoursite.com/tags/data-structure/"/>
    
      <category term="tree" scheme="http://yoursite.com/tags/tree/"/>
    
      <category term="red-black-tree" scheme="http://yoursite.com/tags/red-black-tree/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp源码分析</title>
    <link href="http://yoursite.com/2019/04/25/OkHttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/04/25/OkHttp源码分析/</id>
    <published>2019-04-25T05:51:09.000Z</published>
    <updated>2019-11-21T03:11:22.410Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/okhttp_cover.jpg" alt="okhttp_cover"></p><hr><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">Okhttp</a>是目前Android开发中应用最广泛的网络请求库，效率高，易用，还被Google加入到Android源码当中，我自己也用了三年了，一直没有时间从头到尾真正去分析过它的源码，搞懂它的原理，仅仅停留在熟练的使用阶段，今天就来分析一下Okhttp的源码。</p><p>本文是假定你已经知道Okhttp，并且会使用Okhttp，如果对Okhttp还不熟悉，可以先看看<a href="https://blog.csdn.net/lmj623565791/article/details/47911083" target="_blank" rel="noopener">这篇文章</a>，接下来我们直接进入正文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：本文分析的版本是Okhttp3.10.0 对应的Okio的版本是1.14.0</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="发起一个请求"><a href="#发起一个请求" class="headerlink" title="发起一个请求"></a>发起一个请求</h3><p>先看看发起一个最简单的网络请求用Okhttp是怎样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建一个OkHttpClient</span></span><br><span class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">        .addInterceptor(chain -&gt; chain.proceed(chain.request()))</span><br><span class="line">        .build();</span><br><span class="line"><span class="comment">// 构建一个request</span></span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(<span class="string">""</span>) <span class="comment">// 请求地址</span></span><br><span class="line">        .build();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 发起同步请求，得到响应</span></span><br><span class="line">    Response response = okHttpClient.newCall(request).execute();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是发起一个最简单的同步get请求的示例，可以看见分为三步：</p><ol><li>构建OkhttpClient</li><li>构建Request</li><li>构建Call，发起请求，得到结果</li></ol><p>我们一步步来进入源码中看一看是怎么一回事。</p><h4 id="构建OkhttpClient"><a href="#构建OkhttpClient" class="headerlink" title="构建OkhttpClient"></a>构建OkhttpClient</h4><p>构建OkhttpClient有两种方式，一种是直接new OkhttpClient实例，另一种是通过OkhttpClient内部类Builder构建，其实直接new内部也是通过Builder类构建的。<strong>注意：上面为了示例，是发请求之前直接new的一个示例，OkhttpClient推荐全局使用单例，因为每一个实例都有自己的连接池线程池等，复用能节省资源，减少网络延迟</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> Builder());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dispatcher = <span class="keyword">new</span> Dispatcher();</span><br><span class="line">    protocols = DEFAULT_PROTOCOLS;</span><br><span class="line">    connectionSpecs = DEFAULT_CONNECTION_SPECS;</span><br><span class="line">    eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br><span class="line">    proxySelector = ProxySelector.getDefault();</span><br><span class="line">    cookieJar = CookieJar.NO_COOKIES;</span><br><span class="line">    socketFactory = SocketFactory.getDefault();</span><br><span class="line">    hostnameVerifier = OkHostnameVerifier.INSTANCE;</span><br><span class="line">    certificatePinner = CertificatePinner.DEFAULT;</span><br><span class="line">    proxyAuthenticator = Authenticator.NONE;</span><br><span class="line">    authenticator = Authenticator.NONE;</span><br><span class="line">    connectionPool = <span class="keyword">new</span> ConnectionPool();</span><br><span class="line">    dns = Dns.SYSTEM;</span><br><span class="line">    followSslRedirects = <span class="keyword">true</span>;</span><br><span class="line">    followRedirects = <span class="keyword">true</span>;</span><br><span class="line">    retryOnConnectionFailure = <span class="keyword">true</span>;</span><br><span class="line">    connectTimeout = <span class="number">10_000</span>;</span><br><span class="line">    readTimeout = <span class="number">10_000</span>;</span><br><span class="line">    writeTimeout = <span class="number">10_000</span>;</span><br><span class="line">    pingInterval = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以发现OkhttpClient内部类Builder为我们初始化了很多配置，这些配置我们一一解释一下是干什么用的：</p><ul><li><strong>dispatcher</strong>：请求任务分发器，内部维护两个队列分别保存同步/异步的请求任务，提供给线程池执行，后面会具体分析</li><li><strong>protocols</strong>：支持的协议，默认是支持http1.1和http2，看下源码的表示<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> List&lt;Protocol&gt; DEFAULT_PROTOCOLS = Util.immutableList(Protocol.HTTP_2, Protocol.HTTP_1_1);</span><br></pre></td></tr></table></figure></li><li><strong>connectionSpecs</strong>：连接配置，默认支持CLEARTEXT和TLS两种<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> List&lt;ConnectionSpec&gt; DEFAULT_CONNECTION_SPECS = Util.immutableList(ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// TLS连接</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ConnectionSpec MODERN_TLS = <span class="keyword">new</span> Builder(<span class="keyword">true</span>)</span><br><span class="line">    .cipherSuites(APPROVED_CIPHER_SUITES)</span><br><span class="line">    .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)</span><br><span class="line">    .supportsTlsExtensions(<span class="keyword">true</span>)</span><br><span class="line">    .build();</span><br><span class="line"><span class="comment">// 未加密，未认证的http连接，默认使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ConnectionSpec CLEARTEXT = <span class="keyword">new</span> Builder(<span class="keyword">false</span>).build();</span><br></pre></td></tr></table></figure></li><li><strong>eventListenerFactory</strong>：call监听器，可以监听call的数量，时间，大小等等</li><li><strong>proxySelector</strong>：代理选择器，默认使用系统代理选择器</li><li><strong>cookieJar</strong>：cookie设置，默认没有cookie</li><li><strong>socketFactory</strong>：socket工厂，就是提供socket示例的，okhttp底层网络请求就是socket</li><li><strong>hostnameVerifier</strong>：安全相关，验证主机的</li><li><strong>certificatePinner</strong>：安全相关，证书锁定器，用来验证请求证书的，排除非法连接</li><li><strong>proxyAuthenticator</strong>：安全相关，代理服务器的身份认证</li><li><strong>authenticator</strong>：安全相关，身份认证</li><li><strong>connectionPool</strong>：连接池，okhttp的一大特性，用来减少过度的http请求的连接断开与重连，因为握手和挥手都需要时间</li><li><strong>dns</strong>：dns，域名解析</li><li><strong>followSslRedirects</strong>：是否支持https重定向，默认支持</li><li><strong>followRedirects</strong>：是否支持http重定向，默认支持</li><li><strong>retryOnConnectionFailure</strong>：连接失败是否重试，默认重试</li><li><strong>connectTimeout</strong>：连接超时时间，默认10秒</li><li><strong>readTimeout</strong>：输入流超时时间，默认10秒</li><li><strong>writeTimeout</strong>：输出流超时时间，默认10秒</li><li><strong>pingInterval</strong>：websocket相关，为了保持websocket的长连接，会每隔一段时间ping一下，保持连接，这个值就是ping的间隔时间</li></ul><p>这第一步构建OkHttpClient到这里就完成，其实就是参数的初始化，方便后续的使用，接下来看第二步。</p><h4 id="构建Request"><a href="#构建Request" class="headerlink" title="构建Request"></a>构建Request</h4><p>Request看这命名就知道是封装的一个请求，生成Request实例也是通过Builder模式，通过Request内部类Builder构建，Request的构造方法是default的，外部访问不了。看看Builder类，外部能访问的就只有一个无参构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HttpUrl url; <span class="comment">// url</span></span><br><span class="line">String method; <span class="comment">// 请求方法</span></span><br><span class="line">Headers.Builder headers; <span class="comment">// 请求头</span></span><br><span class="line">RequestBody body; <span class="comment">// 请求体</span></span><br><span class="line">Object tag; <span class="comment">// tag</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.method = <span class="string">"GET"</span>;</span><br><span class="line">    <span class="keyword">this</span>.headers = <span class="keyword">new</span> Headers.Builder();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Request <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"url == null"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Request(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看见，默认是GET方法和空请求头，并且必须设置的只有url，不过其它可选项，比如其它的请求方法，添加或者删除请求头，设置请求体等，builder都提供了静态方法可以设置，这里就不一一列出来了。这一步比较简单，接下来看下一步。</p><h4 id="构建Call，得到结果"><a href="#构建Call，得到结果" class="headerlink" title="构建Call，得到结果"></a>构建Call，得到结果</h4><p>直接看同步请求的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部调用的代码</span></span><br><span class="line">Response response = okHttpClient.newCall(request).execute();</span><br><span class="line"><span class="comment">// okhttpclient中的newCall方法</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RealCall类中的execute方法</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">// 校验是否重复执行</span></span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 追踪调用堆栈信息</span></span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    <span class="comment">// 事件回调</span></span><br><span class="line">    eventListener.callStart(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 提交线程池执行任务</span></span><br><span class="line">        client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        Response result = getResponseWithInterceptorChain();</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        eventListener.callFailed(<span class="keyword">this</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 结束请求</span></span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从源码中可以看到，先是生成Call的实现类RealCall实例，然后执行RealCall的execute方法，该方法内部主要分四步：</p><ul><li>校验重复请求</li><li>请求追踪和事件回调</li><li>提交线程池执行</li><li>获取结果</li></ul><p>以上是同步请求的调用过程，再看看异步请求的源码调用过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部调用的代码</span></span><br><span class="line">okHttpClient.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// okhttpclient中的newCall方法</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RealCall类中的enqueue方法</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">// 校验重复请求</span></span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 请求堆栈跟踪</span></span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    <span class="comment">// 事件回调</span></span><br><span class="line">    eventListener.callStart(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 构建AsyncCall提交至线程池</span></span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>异步请求跟同步的区别就是需要传入回调对象，不需要阻塞等待结果，AsyncCall其实就是Runnable的子类，可直接提交给线程池，它在run方法中主要是调用了execute方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        Response response = getResponseWithInterceptorChain();</span><br><span class="line">        <span class="comment">// 判断是否取消重试，如取消直接走失败回调，未取消，执行回调函数onResponse</span></span><br><span class="line">        <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123; </span><br><span class="line">            signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">            responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">            responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 结束请求</span></span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>异步请求的execute方法跟同步差不多，细心的你可能发现了获取结果都调用了一个叫getResponseWithInterceptorChain的方法，这个后面会详细解释。</p><h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p>Dispatcher是Okhttp的请求调度器，内部负责保存一系列的同步和异步请求，并且负责调用异步请求。</p><h4 id="同步请求调度器的作用"><a href="#同步请求调度器的作用" class="headerlink" title="同步请求调度器的作用"></a>同步请求调度器的作用</h4><p>上一节中同步请求中，调用了dispatcher两个方法，一个是exected(RealCall)方法，另一个是finish(RealCall)方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">executed</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">    runningSyncCalls.add(call);<span class="comment">// 加入到正在运行的同步请求队列中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">    finished(runningSyncCalls, call, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call, <span class="keyword">boolean</span> promoteCalls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> runningCallsCount;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 从正在运行的请求队列中移除请求</span></span><br><span class="line">        <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">        <span class="keyword">if</span> (promoteCalls) promoteCalls(); <span class="comment">// 根据参数是否需要调用promoteCalls方法，同步请求这里是false，暂不介绍</span></span><br><span class="line">        runningCallsCount = runningCallsCount(); <span class="comment">// 重新赋值正在运行的请求数量</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码里可以看见，对于同步请求，调度器的作用就是用一个队列记录一下哪些请求正在执行，这个队列是ArrayDeque，不限容量，容量不足会自动扩容，因此可以判断同步请求理论上是不限数量的，即其它并没有做什么，这里比较简单，接下来看异步请求。</p><h4 id="异步请求调度器的作用"><a href="#异步请求调度器的作用" class="headerlink" title="异步请求调度器的作用"></a>异步请求调度器的作用</h4><p>上一节异步请求中，RealCall的enqueue方法中调用的是dispatcher.enqueue(AsyncCall)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxRequests = <span class="number">64</span>; <span class="comment">// 最大同时执行的请求数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxRequestsPerHost = <span class="number">5</span>; <span class="comment">// 每个主机正在执行的请求数，即连接池中最大的请求数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;(); <span class="comment">// 正在等待的异步请求队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;(); <span class="comment">// 正在执行的异步请求队列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有超出最大请求数量，并且同一个域名下正在执行的请求数量没有超出连接池最大请求数，直接加入线程池执行</span></span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        executorService().execute(call);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则加入等待队列</span></span><br><span class="line">        readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，Okhttp对异步请求做了限制，即最大同时请求数量不超过64个，并且单个主机同时请求数量不超过5个，否则会加入到等待队列中，如果符合要求，就会直接把任务加入到线程池中，之前说过AsyncCall就是Runnable，线程池执行到这个任务时会调用run方法，来看看AsyncCall：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        execute();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取拦截链处理的结果</span></span><br><span class="line">        Response response = getResponseWithInterceptorChain();</span><br><span class="line">        <span class="comment">// 判断是否取消重试，如取消直接走失败回调，未取消，执行回调函数onResponse</span></span><br><span class="line">        <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">            signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">            responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">            responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 结束请求</span></span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到AsyncCall的execute方法逻辑跟RealCall中同步请求的execute方法逻辑差不多，AsyncCall是RealCall的内部类，因此调用的基本是差不多的方法，看一看异步请求调用的dispatcher.finish(AsyncCall)方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    finished(runningAsyncCalls, call, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call, <span class="keyword">boolean</span> promoteCalls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> runningCallsCount;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">        <span class="keyword">if</span> (promoteCalls) promoteCalls(); <span class="comment">// 异步请求这里为true</span></span><br><span class="line">        runningCallsCount = runningCallsCount();</span><br><span class="line">        idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (runningCallsCount == <span class="number">0</span> &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>逻辑跟同步请求一致，不同的就是最后的promoteCalls参数未true，因此会执行promoteCalls方法，再看一看这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">promoteCalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经达到最大同事运行请求数，不做处理</span></span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 如果等待队列为空，也不做处理</span></span><br><span class="line">    <span class="keyword">if</span> (readyAsyncCalls.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 遍历等待队列</span></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        AsyncCall call = i.next();</span><br><span class="line">        <span class="comment">// 如果这个请求对应的主机下请求数量没有达到单主机最大请求数，就添加到线程池中去执行请求</span></span><br><span class="line">        <span class="keyword">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">            i.remove(); <span class="comment">// 从等待队列中移除</span></span><br><span class="line">            runningAsyncCalls.add(call);</span><br><span class="line">            executorService().execute(call);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果请求数满了，不再遍历等待队列，直接退出</span></span><br><span class="line">        <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释已经很详细了，这个方法主要就是从等待队列中取合适的请求继续执行，直到请求被全部执行完成。</p><h3 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h3><p><strong>Interceptor</strong>(拦截器)是Okhttp的另一大特点，能在请求前和响应后都做很多处理，还记得同步和异步请求都是通过一个叫getResponseWithInterceptorChain()的方法得到结果的，先来看一看这个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 自定义的拦截器</span></span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    <span class="comment">// 重试拦截器</span></span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    <span class="comment">// 桥接拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    <span class="comment">// 缓存拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    <span class="comment">// 连接拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123; <span class="comment">// 非websocket请求，还会添加网络拦截器</span></span><br><span class="line">        interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 请求拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line">    <span class="comment">// RealInterceptorChain 内部递归调用每一个拦截器的proceed方法</span></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">        originalRequest, <span class="keyword">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个方法主要是收集所有的拦截器，包括自定义的拦截器和Okhttp内置的五个拦截器，并生成了一个RealInterceptorChain实例，就是这个类的存在，才让okhttp的拦截器链能正常工作。</p><h4 id="RealInterceptorChain"><a href="#RealInterceptorChain" class="headerlink" title="RealInterceptorChain"></a>RealInterceptorChain</h4><p>来看看RealInterceptorChain的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RealInterceptorChain</span><span class="params">(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,</span></span></span><br><span class="line"><span class="function"><span class="params">      HttpCodec httpCodec, RealConnection connection, <span class="keyword">int</span> index, Request request, Call call,</span></span></span><br><span class="line"><span class="function"><span class="params">      EventListener eventListener, <span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.interceptors = interceptors;</span><br><span class="line">    <span class="keyword">this</span>.connection = connection;</span><br><span class="line">    <span class="keyword">this</span>.streamAllocation = streamAllocation;</span><br><span class="line">    <span class="keyword">this</span>.httpCodec = httpCodec;</span><br><span class="line">    <span class="keyword">this</span>.index = index;</span><br><span class="line">    <span class="keyword">this</span>.request = request;</span><br><span class="line">    <span class="keyword">this</span>.call = call;</span><br><span class="line">    <span class="keyword">this</span>.eventListener = eventListener;</span><br><span class="line">    <span class="keyword">this</span>.connectTimeout = connectTimeout;</span><br><span class="line">    <span class="keyword">this</span>.readTimeout = readTimeout;</span><br><span class="line">    <span class="keyword">this</span>.writeTimeout = writeTimeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解释一下各个参数的作用：</p><ul><li><strong>interceptors</strong>：拦截器集合</li><li><strong>connection</strong>：单个连接，即对应的那个请求</li><li><strong>streamAllocation</strong>：流的分配器，内部操作connection、call、streams三个对象</li><li><strong>httpCodec</strong>: http编解码器</li><li><strong>index</strong>：当前执行的拦截器在拦截器集合中的下标</li><li><strong>request</strong>：对应的请求</li><li><strong>call</strong>：对应的请求</li><li><strong>eventListener</strong>：事件监听</li><li><strong>connectTimeout</strong>：连接超时时间，默认10秒</li><li><strong>readTimeout</strong>：输入流超时时间，默认10秒</li><li><strong>writeTimeout</strong>：输出流超时时间，默认10秒</li></ul><p>明白了各个参数的意义，那接下来看proceed方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> calls;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span></span><br><span class="line"><span class="function"><span class="params">      RealConnection connection)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 检测下标异常</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    calls++;<span class="comment">// 调用次数+1</span></span><br><span class="line">    <span class="comment">// 如果是不支持的url，抛出异常</span></span><br><span class="line">    <span class="comment">// supportsUrl方法内部会判断端口是否匹配, 以及如果端口匹配但是host不匹配，还会校验证书</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.connection.supportsUrl(request.url())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">            + <span class="string">" must retain the same host and port"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单个RealInterceptorChain对象的procced只能调用一次校验</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">            + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成新的RealInterceptorChain对象，开始执行拦截器的拦截方法</span></span><br><span class="line">    RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + <span class="number">1</span>, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    <span class="comment">// 在okhttp内置的五个拦截器方法内部都有调用chain.proceed()方法，因此内置的五个拦截器肯定都会调用到</span></span><br><span class="line">    <span class="comment">// 一个拦截器的结果，依赖于下一个拦截器的返回结果，典型的责任链模式</span></span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line">    <span class="comment">// 下面还是几个校验</span></span><br><span class="line">    <span class="keyword">if</span> (httpCodec != <span class="keyword">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptor</span><br><span class="line">            + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"interceptor "</span> + interceptor + <span class="string">" returned null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">"interceptor "</span> + interceptor + <span class="string">" returned a response with no body"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法中最核心的就是生产下一个RealInterceptorChain对象，并且执行拦截器的intercept方法，并且当前的这个返回结果还依赖于下一个拦截器的intercept方法中，调用的RealInterceptorChain.proceed()方法返回的结果，所以就会沿着拦截器链一直调用下去，知道最后一个拦截器返回结果，得到最终的结果。</p><p>接下来再来了解一下Okhttp内置的几个拦截器。</p><h4 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h4><p><strong>RetryAndFollowUpInterceptor</strong>(重试与跟进拦截器)，它会按需求在失败时重试，或者在需要重定向时，自动重定向，来看他的intercept方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">// 最大跟进次数，chrome:21  wget:20   safari:16  http1:5</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_FOLLOW_UPS = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request request = chain.request();</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Call call = realChain.call();</span><br><span class="line">    EventListener eventListener = realChain.eventListener();</span><br><span class="line">    <span class="comment">// 新建一个流操作器</span></span><br><span class="line">    StreamAllocation streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(),</span><br><span class="line">        createAddress(request.url()), call, eventListener, callStackTrace);</span><br><span class="line">    <span class="keyword">this</span>.streamAllocation = streamAllocation;</span><br><span class="line">    <span class="comment">// 重定向次数</span></span><br><span class="line">    <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</span><br><span class="line">    Response priorResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (canceled) &#123; <span class="comment">// 如果取消，释放请求(socket)，抛出异常</span></span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Response response;</span><br><span class="line">      <span class="keyword">boolean</span> releaseConnection = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用proceed，从下一个拦截器中获取结果</span></span><br><span class="line">        response = realChain.proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">        <span class="comment">// 判断是否符合重试的条件，recover函数内部会判断是不是禁止重试、没有更多路由、是否是致命异常等判断</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e.getLastConnectException(), streamAllocation, <span class="keyword">false</span>, request)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e.getLastConnectException();</span><br><span class="line">        &#125;</span><br><span class="line">        releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// 继续重试</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 连接建立失败，继续重试</span></span><br><span class="line">        <span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</span><br><span class="line">        <span class="keyword">if</span> (!recover(e, streamAllocation, requestSendStarted, request)) <span class="keyword">throw</span> e;</span><br><span class="line">        releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (releaseConnection) &#123; <span class="comment">// 按需释放资源</span></span><br><span class="line">          streamAllocation.streamFailed(<span class="keyword">null</span>);</span><br><span class="line">          streamAllocation.release();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 重试得到的response，如果不为空，生成结果</span></span><br><span class="line">      <span class="keyword">if</span> (priorResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                    .body(<span class="keyword">null</span>)</span><br><span class="line">                    .build())</span><br><span class="line">            .build();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// followUpRequest中会对http状态码进行身份认证、代理检测、重定向检测、超时检测等判断，按需生成新的request</span></span><br><span class="line">      <span class="comment">// 如果响应正常，返回null</span></span><br><span class="line">      Request followUp = followUpRequest(response, streamAllocation.route());</span><br><span class="line">      <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">          streamAllocation.release(); <span class="comment">// 释放请求资源</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response; <span class="comment">// 返回结果</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果需要跟进请求，关闭原来的流</span></span><br><span class="line">      closeQuietly(response.body());</span><br><span class="line">      <span class="comment">// 如果跟进次数大于最大可跟进次数，直接释放资源，抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果request被标记为不可重复的请求体，直接释放资源，抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (followUp.body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HttpRetryException(<span class="string">"Cannot retry streamed HTTP body"</span>, response.code());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// sameConnection即url一模一样，如果不是一模一样，释放socket，建立新的socket</span></span><br><span class="line">      <span class="keyword">if</span> (!sameConnection(response, followUp.url())) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(),</span><br><span class="line">            createAddress(followUp.url()), call, eventListener, callStackTrace);</span><br><span class="line">        <span class="keyword">this</span>.streamAllocation = streamAllocation;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (streamAllocation.codec() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Closing the body of "</span> + response</span><br><span class="line">            + <span class="string">" didn't close its backing stream. Bad interceptor?"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 继续重试</span></span><br><span class="line">      request = followUp;</span><br><span class="line">      priorResponse = response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RetryAndFollowUpInterceptor的intercept方法比较长，主要作用就是失败重试以及followUp，followUp包括几种行为，比如重定向，身份认证失败，代理服务器、超时等等需要重试的情况，会根据原始request生成新的request重试，如果状态码是2xx，就直接返回结果了。</p><h4 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h4><p><strong>BridgeInterceptor</strong>(桥接拦截器)，源码解释为：根据用户请求，构建一个网络请求，然后调用网络请求，得到结果，根据网络响应体，构建一个用户响应体。我们来看一看它的intercept方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request userRequest = chain.request();</span><br><span class="line">    Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line">    RequestBody body = userRequest.body();</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">      MediaType contentType = body.contentType();</span><br><span class="line">      <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123; <span class="comment">// 设置Content-Type的请求头</span></span><br><span class="line">        requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">long</span> contentLength = body.contentLength();</span><br><span class="line">      <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123; <span class="comment">// 设置Content-Length请求头</span></span><br><span class="line">        requestBuilder.header(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>); <span class="comment">// 并且移除Transfer-Encoding请求头</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果contentLength等于-1，表示分块传输，这一块不了解的可以上网查下资料</span></span><br><span class="line">        requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果host请求头为空  设置一下</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Host"</span>, hostHeader(userRequest.url(), <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置为长连接</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有指定Accept-Encoding，则设置为gzip</span></span><br><span class="line">    <span class="keyword">boolean</span> transparentGzip = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="keyword">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      transparentGzip = <span class="keyword">true</span>;</span><br><span class="line">      requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有cookie。带上cookie</span></span><br><span class="line">    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">    <span class="keyword">if</span> (!cookies.isEmpty()) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置ua请求头</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"User-Agent"</span>, Version.userAgent());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待结果, 这里是intercept方法的分界处</span></span><br><span class="line">    Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line">    <span class="comment">// 保存cookie，如果需要保存的话</span></span><br><span class="line">    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">    Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest);</span><br><span class="line">    <span class="comment">// 如果是gzip的响应体，并且响应体不为空，通过Okio获取输出流，构建ResponseBody返回，Okio后面会详细介绍</span></span><br><span class="line">    <span class="keyword">if</span> (transparentGzip</span><br><span class="line">        &amp;&amp; <span class="string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="string">"Content-Encoding"</span>))</span><br><span class="line">        &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">      GzipSource responseBody = <span class="keyword">new</span> GzipSource(networkResponse.body().source());</span><br><span class="line">      Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">          .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">          .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">          .build();</span><br><span class="line">      responseBuilder.headers(strippedHeaders);</span><br><span class="line">      String contentType = networkResponse.header(<span class="string">"Content-Type"</span>);</span><br><span class="line">      responseBuilder.body(<span class="keyword">new</span> RealResponseBody(contentType, -<span class="number">1L</span>, Okio.buffer(responseBody)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现BridgeInterceptor拦截器，主要就是为request添加请求头，以及处理response得到ResponseBody，内容很简单，接下来看下一个。</p><h4 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h4><p><strong>CacheInterceptor</strong>(缓存拦截器)，用于缓存网络请求数据，当请求发出时，判断存在有效缓存，就从缓存中读取数据，没有缓存才发送真实请求，收到响应时按需缓存数据，来看一看intercept方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> InternalCache cache;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheInterceptor</span><span class="params">(InternalCache cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = cache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">        ? cache.get(chain.request())</span><br><span class="line">        : <span class="keyword">null</span>; <span class="comment">// 获取缓存</span></span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 根据请求和缓存数据构建缓存策略对象，Factory方法里面会解析缓存数据的过期时间、上次修改时间、etag、Date、age等响应头的数据</span></span><br><span class="line">    <span class="comment">// Factory.get()方法内部会调用getCandidate方法返回CacheStrategy对象</span></span><br><span class="line">    CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    Request networkRequest = strategy.networkRequest;</span><br><span class="line">    Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123; <span class="comment">// 事件追踪</span></span><br><span class="line">      cache.trackResponse(strategy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存数据不对应，不用这个缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">      closeQuietly(cacheCandidate.body());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里相当于没有走网络请求，但是缓存又是空的情况，直接返回504</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">          .request(chain.request())</span><br><span class="line">          .protocol(Protocol.HTTP_1_1)</span><br><span class="line">          .code(<span class="number">504</span>)</span><br><span class="line">          .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">          .body(Util.EMPTY_RESPONSE)</span><br><span class="line">          .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果拿到了缓存，直接返回缓存数据</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line">    Response networkResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">// 等待下一个拦截器返回结果, 走到这里相当于是发起网络请求，不走缓存</span></span><br><span class="line">      networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body());<span class="comment">// 这里是当网络请求出错时，保护好缓存数据，正确的关闭缓存流数据</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        <span class="comment">// 如果状态码是HTTP_NOT_MODIFIED，即缓存数据有效，网络数据并没有发生变化，将缓存数据和网络数据合并</span></span><br><span class="line">        Response response = cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build();</span><br><span class="line">        networkResponse.body().close(); <span class="comment">// 关闭网络数据流</span></span><br><span class="line">        <span class="comment">// 更新缓存数据</span></span><br><span class="line">        cache.trackConditionalCacheHit();</span><br><span class="line">        cache.update(cacheResponse, response);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        closeQuietly(cacheResponse.body()); <span class="comment">// 如果缓存没有效了，直接关闭缓存数据流</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里是直接使用网络数据</span></span><br><span class="line">    Response response = networkResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">        <span class="comment">// 缓存数据</span></span><br><span class="line">        CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">        <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">// 如果是无效缓存，直接移除, 如POST、PATCH这些请求</span></span><br><span class="line">          cache.remove(networkRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">          <span class="comment">// The cache cannot be written.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回网络请求结果</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的源码，来总结一下缓存的大体策略：</p><ol><li>请求被设置为只走缓存，但是缓存数据无效的情况下，直接返回504</li><li>有有效缓存数据，并且不需要走网络请求(缓存数据是不可变的)，直接返回缓存数据</li><li>走网络请求，但是网络请求响应状态码为HTTP_NOT_MODIFIED，合并网络和缓存数据，返回合并后的数据，并且更新缓存</li><li>响应状态码不是HTTP_NOT_MODIFIED，返回网络请求的数据，按需决定是否需要缓存此次数据</li></ol><p>这些情况里，决定结果的是CacheStrategy.Factory(now, chain.request(), cacheCandidate).get()方法返回的缓存策略里的两个对象，再来看一下这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheStrategy <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CacheStrategy candidate = getCandidate(); <span class="comment">// 调用getCandidate方法返回缓存策略实例</span></span><br><span class="line">    <span class="keyword">if</span> (candidate.networkRequest != <span class="keyword">null</span> &amp;&amp; request.cacheControl().onlyIfCached()) &#123;</span><br><span class="line">    <span class="comment">// 网络请求对象不为空，即缓存数据是没有效的，但是原始请求的缓存控制设置为只走缓存，即不走网络请求，就会返回networkRequest和 cacheResponse都为空的CacheStrategy，这里对应上面第一种返回504的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> CacheStrategy <span class="title">getCandidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cacheResponse == <span class="keyword">null</span>) &#123; <span class="comment">// 缓存数据为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是https，并且没有走过https的安全握手阶段，也不拿缓存数据</span></span><br><span class="line">    <span class="keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不可缓存的响应和请求，即header中存在no-store，也不走缓存</span></span><br><span class="line">    <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    CacheControl requestCaching = request.cacheControl();</span><br><span class="line">    <span class="comment">// 如果本次请求头里有no-cache字段，或者有If-Modified-Since或者If-None-Match字段，也不走缓存</span></span><br><span class="line">    <span class="keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    CacheControl responseCaching = cacheResponse.cacheControl();</span><br><span class="line">    <span class="keyword">if</span> (responseCaching.immutable()) &#123; <span class="comment">// 如果缓存数据是不可变的，即包换immutable响应头，直接返回缓存，不走网络</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, cacheResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> ageMillis = cacheResponseAge();</span><br><span class="line">    <span class="keyword">long</span> freshMillis = computeFreshnessLifetime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> minFreshMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> maxStaleMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">        <span class="comment">// 这里表示缓存可用，但是已经过期了，就会添加Warning响应头，并且返回缓存</span></span><br><span class="line">        Response.Builder builder = cacheResponse.newBuilder();</span><br><span class="line">        <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">            builder.addHeader(<span class="string">"Warning"</span>, <span class="string">"110 HttpURLConnection \"Response is stale\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>;</span><br><span class="line">        <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">            builder.addHeader(<span class="string">"Warning"</span>, <span class="string">"113 HttpURLConnection \"Heuristic expiration\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, builder.build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String conditionName;</span><br><span class="line">    String conditionValue;</span><br><span class="line">    <span class="keyword">if</span> (etag != <span class="keyword">null</span>) &#123; <span class="comment">// etag不为空，往请求头里添加If-None-Match字段，值是etag的值，用于服务器判断资源是否经过修改</span></span><br><span class="line">        conditionName = <span class="string">"If-None-Match"</span>;</span><br><span class="line">        conditionValue = etag;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastModified != <span class="keyword">null</span>) &#123; <span class="comment">// lastModified不为空，添加If-Modified-Since字段</span></span><br><span class="line">        conditionName = <span class="string">"If-Modified-Since"</span>;</span><br><span class="line">        conditionValue = lastModifiedString;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servedDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">"If-Modified-Since"</span>;</span><br><span class="line">        conditionValue = servedDateString;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();</span><br><span class="line">    Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建新的请求对象并返回，这个请求会发送到服务器</span></span><br><span class="line">    Request conditionalRequest = request.newBuilder()</span><br><span class="line">        .headers(conditionalRequestHeaders.build())</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(conditionalRequest, cacheResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来总结一下这一段的各种情况的分支：</p><ol><li>没有缓存可用，直接走网络请求</li><li>是https请求，但是没有经过握手建立连接，也走网络</li><li>如果是不可缓存的，直接走网络请求</li><li>如果有no-cache响应头，或者请求头里有If-None-Match或者If-Modified-Since字段，也直接走网络，只不过需要服务器判断缓存是否有效</li><li>缓存有效，但是过期了，用缓存，但是有警告</li><li>缓存过期，按需是否添加对应的If-None-Match或者If-Modified-Since字段，走网络请求</li></ol><p>到这里CacheInterceptor就看完了，主要就是根据各种情况判断是否是用缓存还是不用缓存，细心的人也许发现，CacheInterceptor构造方法里传进来的InternalCache没有说，这里其实就是OkhttpClient初始化时通过Builder设置的cache，如果没有设置，cache就是空，那就是上面第一种情况，直接走网络请求。</p><h4 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h4><p><strong>ConnectInterceptor</strong>(连接拦截器)，作用是打开一个连接，连接到目标服务器，我们来看它的intercept方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</span><br><span class="line">    <span class="comment">// 新建一个连接</span></span><br><span class="line">    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    RealConnection connection = streamAllocation.connection();</span><br><span class="line">    <span class="comment">// 调用chain.proceed方法，进入下一个拦截器</span></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见核心代码很少，但是其实重要的步骤都被封装到streamAllocation对象里了，我们继续跟进，看streamAllocation.newStream方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpCodec <span class="title">newStream</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      OkHttpClient client, Interceptor.Chain chain, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是超时时间</span></span><br><span class="line">    <span class="keyword">int</span> connectTimeout = chain.connectTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> readTimeout = chain.readTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> writeTimeout = chain.writeTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> pingIntervalMillis = client.pingIntervalMillis(); <span class="comment">// 长连接需要的ping间隔时间，上面有解释到</span></span><br><span class="line">    <span class="keyword">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure(); <span class="comment">// 是否需要连接失败时重试</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 寻找可用的连接</span></span><br><span class="line">        RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">            writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class="line">        HttpCodec resultCodec = resultConnection.newCodec(client, chain, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">            codec = resultCodec;</span><br><span class="line">            <span class="keyword">return</span> resultCodec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RealConnection <span class="title">findHealthyConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> writeTimeout, <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class="line">            pingIntervalMillis, connectionRetryEnabled);</span><br><span class="line">        <span class="keyword">synchronized</span> (connectionPool) &#123; <span class="comment">// 如果是一个新连接，可以直接使用，不用检查是否是好的</span></span><br><span class="line">            <span class="keyword">if</span> (candidate.successCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> candidate;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检测从连接池中获取到的连接是否正常可用，不可用就继续找连接</span></span><br><span class="line">        <span class="keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">            noNewStreams(); <span class="comment">// 将连接从连接池中移除并释放资源</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代码主要就是调用findConnection寻找未在使用的连接，然后判断是否是正常可用的，这个isHealthy方法内部判断的是socket以及socket的输入输出流是否正常连接和打开状态，如果是http2，判断长连接是否被关闭了，以及socket连接是否会超时，如果正常，就会返回该连接对象回去。我们再来看看findConnection方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RealConnection <span class="title">findConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> foundPooledConnection = <span class="keyword">false</span>;<span class="comment">// 是否发现连接池里的连接</span></span><br><span class="line">    RealConnection result = <span class="keyword">null</span>;</span><br><span class="line">    Route selectedRoute = <span class="keyword">null</span>;</span><br><span class="line">    Connection releasedConnection; </span><br><span class="line">    Socket toClose;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123; <span class="comment">// 连接池为锁</span></span><br><span class="line">      <span class="keyword">if</span> (released) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"released"</span>);</span><br><span class="line">      <span class="keyword">if</span> (codec != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"codec != null"</span>);</span><br><span class="line">      <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line"></span><br><span class="line">      releasedConnection = <span class="keyword">this</span>.connection;</span><br><span class="line">      toClose = releaseIfNoNewStreams(); <span class="comment">// 如果连接不可用，从连接池中移除并释放资源，返回待释放的socket</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.connection != <span class="keyword">null</span>) &#123; <span class="comment">// 到这里不为空，说明连接可用</span></span><br><span class="line">        <span class="comment">// 当前连接不为空，直接赋值</span></span><br><span class="line">        result = <span class="keyword">this</span>.connection;</span><br><span class="line">        releasedConnection = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!reportedAcquired) &#123;</span><br><span class="line">        releasedConnection = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从连接池内获取可用连接，会赋值给当前allocation对象的connection变量</span></span><br><span class="line">        Internal.instance.get(connectionPool, address, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123; <span class="comment">// 连接池内有可用连接</span></span><br><span class="line">          foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">          result = connection;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          selectedRoute = route;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closeQuietly(toClose);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (releasedConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">        eventListener.connectionReleased(call, releasedConnection);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">        eventListener.connectionAcquired(call, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result; <span class="comment">// 返回连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里说明没有可用的连接，hasNext是阻塞操作，得到路由集</span></span><br><span class="line">    <span class="keyword">boolean</span> newRouteSelection = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span> &amp;&amp; (routeSelection == <span class="keyword">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class="line">      newRouteSelection = <span class="keyword">true</span>;</span><br><span class="line">      routeSelection = routeSelector.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      <span class="keyword">if</span> (newRouteSelection) &#123;</span><br><span class="line">        <span class="comment">// 这是上面获取到的路由集合(即目标服务器的http代理服务器，或者ip地址)</span></span><br><span class="line">        List&lt;Route&gt; routes = routeSelection.getAll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = routes.size(); i &lt; size; i++) &#123;</span><br><span class="line">          Route route = routes.get(i);</span><br><span class="line">          <span class="comment">// 再从连接池中去获取</span></span><br><span class="line">          Internal.instance.get(connectionPool, address, <span class="keyword">this</span>, route);</span><br><span class="line">          <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123; <span class="comment">// 不为空说明连接池返回了可用的连接，直接退出轮询</span></span><br><span class="line">            foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">            result = connection;</span><br><span class="line">            <span class="keyword">this</span>.route = route;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!foundPooledConnection) &#123; <span class="comment">// 如果没有找到可用的，直接用第一个路由信息创建新的连接</span></span><br><span class="line">        <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span>) &#123;</span><br><span class="line">          selectedRoute = routeSelection.next();</span><br><span class="line">        &#125;</span><br><span class="line">        route = selectedRoute;</span><br><span class="line">        refusedStreamCount = <span class="number">0</span>;</span><br><span class="line">        result = <span class="keyword">new</span> RealConnection(connectionPool, selectedRoute);</span><br><span class="line">        <span class="comment">// 这个方法是把新生成的连接赋值给当前allocation对象，并创建一个StreamAllocationReference引用添加到这个连接的allocations集合中</span></span><br><span class="line">        <span class="comment">// StreamAllocationReference用于追踪连接，当发生连接泄漏时，它能帮助找到这个连接</span></span><br><span class="line">        acquire(result, <span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 即从路由集中任意一个路由对应的连接池中获取到了可用连接</span></span><br><span class="line">    <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接socket，过程是http握手阶段，如果是https还包括tls握手</span></span><br><span class="line">    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled, call, eventListener);</span><br><span class="line">    <span class="comment">// routeDatabase是一个记录对应ip连接失败的黑名单，如果这个ip连接失败过，之后的这个ip的请求，就可以避免再次请求了，在上面routeSelection.next()方法中会有这个判断</span></span><br><span class="line">    routeDatabase().connected(result.route());</span><br><span class="line"></span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      reportedAcquired = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 把新建的连接，放入连接池</span></span><br><span class="line">      Internal.instance.put(connectionPool, result);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这里的意思是如果是http2，就是同一个地址可以复用的连接已经被创建了，那就关闭当前这个新建的，用那个已经创建的连接</span></span><br><span class="line">      <span class="keyword">if</span> (result.isMultiplexed()) &#123;</span><br><span class="line">        socket = Internal.instance.deduplicate(connectionPool, address, <span class="keyword">this</span>);</span><br><span class="line">        result = connection;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closeQuietly(socket);</span><br><span class="line">    eventListener.connectionAcquired(call, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这一段代码很长，主要步骤分为以下几个：</p><ol><li>当前已经有一个创建好的连接并且是可用，那么直接返回</li><li>如果当前已存在的连接不可用(noNewStreams), 去连接池中查找</li><li>如果连接池中没找到可用的，从目标服务器的多个路由地址对应的连接池中一一去查找</li><li>如果还没找到，创建新的连接</li><li>连接socket，http握手</li><li>放入连接池，判断是否是http2(支持多路复用)连接，如果是，关闭当前新建的连接，用已经存在的可复用的连接</li></ol><p>大概就是这六步，再来看看这里面多次用到的连接池具体是个什么东西。</p><p>连接池是okhttp为了减少网络延迟创建的一个管理同一个路由的连接的，若是频繁调用的同一个路由的请求，可以保持连接存活并且复用，减少了一次断开和连接的过程，ConnectionPool中有两个比较重要的全局变量，executor和connections，分别是线程池和连接队列，先来看看连接池的put方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>)); <span class="comment">// 保证原子性</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanupRunning) &#123;</span><br><span class="line">        cleanupRunning = <span class="keyword">true</span>;</span><br><span class="line">        executor.execute(cleanupRunnable); <span class="comment">// 清理连接池</span></span><br><span class="line">    &#125;</span><br><span class="line">    connections.add(connection); <span class="comment">// 加入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> waitNanos = cleanup(System.nanoTime());<span class="comment">// 获取需要等待的时长，如果为0，继续循环调用</span></span><br><span class="line">        <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">// 返回-1表示没有需要清理的</span></span><br><span class="line">        <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">long</span> waitMillis = waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">          waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">          <span class="keyword">synchronized</span> (ConnectionPool.<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 等待</span></span><br><span class="line">              ConnectionPool.<span class="keyword">this</span>.wait(waitMillis, (<span class="keyword">int</span>) waitNanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> inUseConnectionCount = <span class="number">0</span>; <span class="comment">// 正在使用的连接数量</span></span><br><span class="line">    <span class="keyword">int</span> idleConnectionCount = <span class="number">0</span>; <span class="comment">// 空闲连接数量</span></span><br><span class="line">    RealConnection longestIdleConnection = <span class="keyword">null</span>; <span class="comment">// 空闲最长的连接</span></span><br><span class="line">    <span class="keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE; <span class="comment">// 最长空闲等待时长,纳秒</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历连接池</span></span><br><span class="line">      <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        RealConnection connection = i.next();</span><br><span class="line">        <span class="comment">// 连接正在使用中,pruneAndGetAllocationCount方法是统计正在运行的连接streamAllocation数量，并且会移除发生泄漏的streamAllocation</span></span><br><span class="line">        <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          inUseConnectionCount++;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到这里说明是空闲连接，即将被kill的</span></span><br><span class="line">        idleConnectionCount++;</span><br><span class="line">        <span class="keyword">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class="line">        <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">          longestIdleDurationNs = idleDurationNs;</span><br><span class="line">          longestIdleConnection = connection;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs</span><br><span class="line">          || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;</span><br><span class="line">        <span class="comment">// 空闲连接需要等待的时长大于最大时长，或者等待的空闲连接数已经达到最大值，直接移除等待最长的那个空闲连接</span></span><br><span class="line">        connections.remove(longestIdleConnection);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回等待最久的那个空闲连接还需要等待多久就不需要等待了的时间值</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// idleConnectionCount &lt;= 0 并且 inUseConnectionCount &gt; 0,说明没有空闲连接</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 连接池没有连接</span></span><br><span class="line">        cleanupRunning = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closeQuietly(longestIdleConnection.socket());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put方法很简单，只是put方法里调用的清理连接池的runnable不简单，这个runnable主要就是清理等待时长大于最大等待时长(Long.MIN_VALUE)的空闲连接和超出最大空闲连接数量的空闲连接。接下来看一看get方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span> <span class="function">RealConnection <span class="title">get</span><span class="params">(Address address, StreamAllocation streamAllocation, Route route)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>)); <span class="comment">// 保证原子性</span></span><br><span class="line">    <span class="keyword">for</span> (RealConnection connection : connections) &#123;</span><br><span class="line">        <span class="comment">// 返回当前链接还能否携带streamAllocation，默认是1个</span></span><br><span class="line">        <span class="comment">// 如果是已经释放的streamAllocation，当前链接的allocations就是空的</span></span><br><span class="line">      <span class="keyword">if</span> (connection.isEligible(address, route)) &#123;</span><br><span class="line">          <span class="comment">// 互相绑定</span></span><br><span class="line">        streamAllocation.acquire(connection, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从连接池获取连接的方法也很简单，主要是借助isEligible方法判断是否是可用的连接，这个方法内部也有几个判断，主要就是判断连接的allocations大小、host和address检测、HTTP2检测、代理检测、身份认证等等判断。</p><h4 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h4><p><strong>CallServerInterceptor</strong>(调用服务器拦截器)，这是拦截器链最后一个拦截器，主要作用就是发起请求了，我们来看一看它的intercept方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    HttpCodec httpCodec = realChain.httpStream();</span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">    RealConnection connection = (RealConnection) realChain.connection();</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line">    realChain.eventListener().requestHeadersStart(realChain.call());</span><br><span class="line">    httpCodec.writeRequestHeaders(request);<span class="comment">// 写headers</span></span><br><span class="line">    realChain.eventListener().requestHeadersEnd(realChain.call(), request);</span><br><span class="line"></span><br><span class="line">    Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 非get/head方法，判断100-continue请求头</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"100-continue"</span>.equalsIgnoreCase(request.header(<span class="string">"Expect"</span>))) &#123;</span><br><span class="line">        httpCodec.flushRequest();</span><br><span class="line">        realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">        responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        realChain.eventListener().requestBodyStart(realChain.call());</span><br><span class="line">        <span class="keyword">long</span> contentLength = request.body().contentLength();</span><br><span class="line">        CountingSink requestBodyOut =</span><br><span class="line">            <span class="keyword">new</span> CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class="line">        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line"></span><br><span class="line">        request.body().writeTo(bufferedRequestBody);</span><br><span class="line">        bufferedRequestBody.close();</span><br><span class="line">        realChain.eventListener()</span><br><span class="line">            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!connection.isMultiplexed()) &#123;</span><br><span class="line">        streamAllocation.noNewStreams();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    httpCodec.finishRequest();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">      realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">      responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response = responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(streamAllocation.connection().handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> code = response.code();</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">      <span class="comment">// server sent a 100-continue even though we did not request one.</span></span><br><span class="line">      <span class="comment">// try again to read the actual response</span></span><br><span class="line">      responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">      response = responseBuilder</span><br><span class="line">              .request(request)</span><br><span class="line">              .handshake(streamAllocation.connection().handshake())</span><br><span class="line">              .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">              .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">              .build();</span><br><span class="line"></span><br><span class="line">      code = response.code();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    realChain.eventListener()</span><br><span class="line">            .responseHeadersEnd(realChain.call(), response);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">      <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">      response = response.newBuilder()</span><br><span class="line">          .body(Util.EMPTY_RESPONSE)</span><br><span class="line">          .build();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      response = response.newBuilder()</span><br><span class="line">          .body(httpCodec.openResponseBody(response))</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="string">"Connection"</span>))</span><br><span class="line">        || <span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</span><br><span class="line">      streamAllocation.noNewStreams();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</span><br><span class="line">          <span class="string">"HTTP "</span> + code + <span class="string">" had non-zero Content-Length: "</span> + response.body().contentLength());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段代码没什么好解释的，大概就是借助HttpCodec发送请求，主要是写请求头和读响应头，构建Response返回给上一层，responseBody最终是在BridgeInterceptor中读取gzip数据赋值或者在CacheInterceptor中读取缓存数据赋值。</p><p>HttpCodec在okhttp中是一个接口，主要是编码请求和解码响应，有两个实现，HttpCodec1和HttpCodec2，分别对应http1和http2的编解码，内部使用的是Okio进行数据流读写，Okio后续再单独开一篇记录。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里就基本上分析完成了，Okhttp的整个过程就是这样子的，在网上找到了一张描述比较全面的Okhttp架构图：<br><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/okhttp_architecture.jpg" alt="okhttp">(出自  <a href="https://yq.aliyun.com/articles/78105?spm=5176.100239.blogcont78104.10.FlPFWr" target="_blank" rel="noopener">https://yq.aliyun.com/articles/78105?spm=5176.100239.blogcont78104.10.FlPFWr</a> )，现在回头来看这张图，感觉非常清晰。</p><p>现在来看一下Okhttp官网介绍的几个特性：<br>    OkHttp is an HTTP client that’s efficient by default:</p><pre><code>1. HTTP/2 support allows all requests to the same host to share a socket.2. Connection pooling reduces request latency (if HTTP/2 isn’t available).3. Transparent GZIP shrinks download sizes.4. Response caching avoids the network completely for repeat requests.</code></pre><p>翻译一下就是：</p><ol><li>支持http2，多个请求共享一个socket</li><li>连接池减少网络延迟</li><li>gzip格式压缩数据，减少传输成本</li><li>缓存控制</li></ol><p>无比清晰呀，现在能想起这几个特性分别在哪一步的分析过程中出现过吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/huangzhengneng/ImageFactory/raw/master/blog/okhttp_cover.jpg&quot; alt=&quot;okhttp_cover&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="source analysis" scheme="http://yoursite.com/tags/source-analysis/"/>
    
      <category term="okhttp" scheme="http://yoursite.com/tags/okhttp/"/>
    
  </entry>
  
  <entry>
    <title>Android-App安装过程分析</title>
    <link href="http://yoursite.com/2019/01/10/Android-App%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/01/10/Android-App安装过程分析/</id>
    <published>2019-01-10T10:01:44.000Z</published>
    <updated>2019-11-21T03:11:22.409Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/app_install_flow_cover.jpeg" alt="app_install_flow"></p><hr><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>以前从来没有关注过app安装具体是怎样一个流程，apk文件中的各个模块什么时候被解析的，这次自己查看了源码，跟踪了安装app的具体流程，终于大体弄明白了。本文将从点击apk文件安装，到打开首页整个过程分析源代码，主要涉及PackageInstaller的系统app。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文基于Android 7.1.0 api25源码分析</span><br></pre></td></tr></table></figure></p><h2 id="click-install"><a href="#click-install" class="headerlink" title="click install"></a>click install</h2><h3 id="PackageInstallerActivity"><a href="#PackageInstallerActivity" class="headerlink" title="PackageInstallerActivity"></a>PackageInstallerActivity</h3><p>通过adb命令<code>adb shell dumpsys activity | grep &quot;mFocusedActivity&quot;</code>可以看到点击安装app时，当前的Activity是PackageInstallerActivity，该activity是系统内置应用PackageInstaller的MainActivity，跳过前面的权限判断、uri解析等步骤，关注我们点击该页面的安装按钮时，调用的是PackageInstallerActivity.startInstall()方法：<br><figure class="highlight java"><figcaption><span>PackageInstallerActivity.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startInstall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Start subactivity to actually install the application</span></span><br><span class="line">    Intent newIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">    <span class="comment">// applicationInfo</span></span><br><span class="line">    newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO,</span><br><span class="line">            mPkgInfo.applicationInfo);</span><br><span class="line">    <span class="comment">// packageUri</span></span><br><span class="line">    newIntent.setData(mPackageURI);</span><br><span class="line">    <span class="comment">// 启动名叫InstallAppProgress的Activity</span></span><br><span class="line">    newIntent.setClass(<span class="keyword">this</span>, InstallAppProgress<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line">    startActivity(newIntent);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="InstallAppProgress"><a href="#InstallAppProgress" class="headerlink" title="InstallAppProgress"></a>InstallAppProgress</h3><p>startInstall()方法就是开启了InstallAppProgress页面，并传入相关app的参数，来到InstallAppProgressActivity，重点在initView方法内：<br><figure class="highlight java"><figcaption><span>InstallAppProgress.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"package"</span>.equals(mPackageURI.getScheme())) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pm.installExistingPackage(mAppInfo.packageName);</span><br><span class="line">            onPackageInstalled(PackageInstaller.STATUS_SUCCESS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            onPackageInstalled(PackageInstaller.STATUS_FAILURE_INVALID);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        mInstallHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                doPackageStage(pm, params);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>若该app已经存在系统中了，就会调用PackageManager的installExistingPackage方法，这种主要是系统中有多个用户，其中一个用户安装另一个用户已经安装了的app，就会走这个逻辑，installExistingPackage方法也主要就是修改一些针对当前系统用户的设置信息和创建app的一些数据。else分支就是我们正常安装一个新app的逻辑doPackageStage()方法：<br><figure class="highlight java"><figcaption><span>InstallAppProgress.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doPackageStage</span><span class="params">(PackageManager pm, PackageInstaller.SessionParams params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> PackageInstaller packageInstaller = pm.getPackageInstaller();</span><br><span class="line">    PackageInstaller.Session session = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> String packageLocation = mPackageURI.getPath();</span><br><span class="line">        ...</span><br><span class="line">        session = packageInstaller.openSession(sessionId);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Create a PendingIntent and use it to generate the IntentSender</span></span><br><span class="line">        Intent broadcastIntent = <span class="keyword">new</span> Intent(BROADCAST_ACTION);</span><br><span class="line">        PendingIntent pendingIntent = PendingIntent.getBroadcast(</span><br><span class="line">                InstallAppProgress.<span class="keyword">this</span> <span class="comment">/*context*/</span>,</span><br><span class="line">                sessionId,</span><br><span class="line">                broadcastIntent,</span><br><span class="line">                PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line">        <span class="comment">// 进入PackageInstaller.Session</span></span><br><span class="line">        session.commit(pendingIntent.getIntentSender());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        onPackageInstalled(PackageInstaller.STATUS_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="PackageInstaller"><a href="#PackageInstaller" class="headerlink" title="PackageInstaller"></a>PackageInstaller</h3><p>doPackageStage()方法最终会进入PackageInstaller中：<br><figure class="highlight java"><figcaption><span>PackageInstaller.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">Session <span class="title">openSession</span><span class="params">(<span class="keyword">int</span> sessionId)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// mInstaller是IPackageInstaller类型，该接口的具体实现是PackageInstallerService类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Session(mInstaller.openSession(sessionId));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><figcaption><span>PackageInstaller.Session</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(@NonNull IntentSender statusReceiver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// mSession即上面mInstaller.openSession方法返回值</span></span><br><span class="line">        <span class="comment">// 类型是IPackageInstallerSession，该接口的具体实现是PackageInstallerSession类</span></span><br><span class="line">        mSession.commit(statusReceiver);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="PackageInstallerSession"><a href="#PackageInstallerSession" class="headerlink" title="PackageInstallerSession"></a>PackageInstallerSession</h3><p>上面从PackageInstaller类到其内部类Session的commit()方法，中间传入PackageInstallerService.openSession方法返回的PackageInstallerSession实例，最终调用了PackageInstallerSession.commit()方法：<br><figure class="highlight java"><figcaption><span>PackageInstallerSession.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(IntentSender statusReceiver)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> PackageInstallObserverAdapter adapter = <span class="keyword">new</span> PackageInstallObserverAdapter(mContext,</span><br><span class="line">            statusReceiver, sessionId, mIsInstallerDeviceOwner, userId);</span><br><span class="line">    <span class="comment">// 交给handler处理，该handler只有一种what，直接在全局变量mHandlerCallback的handleMessage方法中处理了</span></span><br><span class="line">    mHandler.obtainMessage(MSG_COMMIT, adapter.getBinder()).sendToTarget();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Handler.Callback mHandlerCallback = <span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            commitLocked(pkgInfo, appInfo);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PackageManagerException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">commitLocked</span><span class="params">(PackageInfo pkgInfo, ApplicationInfo appInfo)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> PackageManagerException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 验证apk，签名，包名等信息</span></span><br><span class="line">    validateInstallLocked(pkgInfo, appInfo);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 解压native即apk包下lib文件夹下的内容，复制当前机型的cpu对应abi类型的二进制文件</span></span><br><span class="line">    extractNativeLibraries(mResolvedStageDir, params.abiOverride);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// mPm是IPackageManager类型，具体实现就是PackageManagerService(PKMS)</span></span><br><span class="line">    mPm.installStage(mPackageName, stageDir, stageCid, localObserver, params,</span><br><span class="line">                installerPackageName, installerUid, user, mCertificates);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><h3 id="PackageManagerService"><a href="#PackageManagerService" class="headerlink" title="PackageManagerService"></a>PackageManagerService</h3><p>从上面的代码中可以看见，经过PackageInstallerSession内部的流转，最终进入PackageManagerService中，在进入PKMS中之前，会获取apk内的native库。接下来进入PKMS：<br><figure class="highlight java"><figcaption><span>PackageManagerService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">installStage</span><span class="params">(String packageName, File stagedDir, String stagedCid,</span></span></span><br><span class="line"><span class="function"><span class="params">            IPackageInstallObserver2 observer, PackageInstaller.SessionParams sessionParams,</span></span></span><br><span class="line"><span class="function"><span class="params">            String installerPackageName, <span class="keyword">int</span> installerUid, UserHandle user,</span></span></span><br><span class="line"><span class="function"><span class="params">            Certificate[][] certificates)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> Message msg = mHandler.obtainMessage(INIT_COPY);</span><br><span class="line">    <span class="keyword">final</span> InstallParams params = <span class="keyword">new</span> InstallParams(origin, <span class="keyword">null</span>, observer,</span><br><span class="line">            sessionParams.installFlags, installerPackageName, sessionParams.volumeUuid,</span><br><span class="line">            verificationInfo, user, sessionParams.abiOverride,</span><br><span class="line">            sessionParams.grantedRuntimePermissions, certificates);</span><br><span class="line">    msg.obj = params;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 进入handler，what=INIT_COPY</span></span><br><span class="line">    mHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>installStage方法会进入Handler#handleMessage方法中，该方法内有几处流转：<br><figure class="highlight java"><figcaption><span>PackageManagerService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doHandleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> INIT_COPY: &#123;</span><br><span class="line">            HandlerParams params = (HandlerParams) msg.obj;</span><br><span class="line">            <span class="keyword">int</span> idx = mPendingInstalls.size();</span><br><span class="line">            <span class="keyword">if</span> (!mBound) &#123; <span class="comment">// mBound表示绑定过该次安装的intent，安装完成会解绑</span></span><br><span class="line">                <span class="comment">// 绑定成功会加入到mPendingInstalls的list中待安装，即系统同一时间只能安装一个app，其它的在list中排队</span></span><br><span class="line">                <span class="keyword">if</span> (!connectToService()) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mPendingInstalls.add(idx, params);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mPendingInstalls.add(idx, params);</span><br><span class="line">                <span class="keyword">if</span> (idx == <span class="number">0</span>) &#123; <span class="comment">// 进入MCS_BOUND</span></span><br><span class="line">                    mHandler.sendEmptyMessage(MCS_BOUND);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">case</span> MCS_BOUND: &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (mPendingInstalls.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            HandlerParams params = mPendingInstalls.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (params != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (params.startCopy()) &#123; <span class="comment">// 重点，进入拷贝apk阶段</span></span><br><span class="line">                    <span class="keyword">if</span> (mPendingInstalls.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        mPendingInstalls.remove(<span class="number">0</span>);<span class="comment">// 移除</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (mPendingInstalls.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (mBound) &#123;</span><br><span class="line">                            ... <span class="comment">// 解绑</span></span><br><span class="line">                            sendMessageDelayed(MCS_UNBIND, <span class="number">10000</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ... <span class="comment">// 递归安装下一个</span></span><br><span class="line">                        mHandler.sendEmptyMessage(MCS_BOUND);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="PackageManagerService-InstallParams"><a href="#PackageManagerService-InstallParams" class="headerlink" title="PackageManagerService.InstallParams"></a>PackageManagerService.InstallParams</h3><p>上面的代码中可以看见，系统是按照顺序一个一个安装app的，安装时进入HandlerParams.startCopy方法，该方法又进入handleStartCopy方法，这是个抽象方法，具体实现在InstallParams类中，上面installStage方法的代码中也能看见传入的就是InstallParams实例:<br><figure class="highlight java"><figcaption><span>PackageManagerService.InstallParams</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStartCopy</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = PackageManager.INSTALL_SUCCEEDED;</span><br><span class="line">    <span class="comment">// 返回的是FileInstallArgs类实例</span></span><br><span class="line">    <span class="keyword">final</span> InstallArgs args = createInstallArgs(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (ret == PackageManager.INSTALL_SUCCEEDED</span><br><span class="line">                            &amp;&amp; mRequiredVerifierPackage != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            mContext.sendOrderedBroadcastAsUser(verification, verifierUser,</span><br><span class="line">                    android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,</span><br><span class="line">                    <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">final</span> Message msg = mHandler</span><br><span class="line">                                    .obtainMessage(CHECK_PENDING_VERIFICATION);</span><br><span class="line">                            msg.arg1 = verificationId;</span><br><span class="line">                            <span class="comment">// 再次进入handler,what=CHECK_PENDING_VERIFICATION</span></span><br><span class="line">                            mHandler.sendMessageDelayed(msg, getVerificationTimeout());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doHandleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> CHECK_PENDING_VERIFICATION: &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 安装</span></span><br><span class="line">            processPendingInstall(args, ret);</span><br><span class="line">            <span class="comment">// 解绑</span></span><br><span class="line">            mHandler.sendEmptyMessage(MCS_UNBIND);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="PackageManagerService-1"><a href="#PackageManagerService-1" class="headerlink" title="PackageManagerService"></a>PackageManagerService</h3><figure class="highlight java"><figcaption><span>PackageManagerService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processPendingInstall</span><span class="params">(<span class="keyword">final</span> InstallArgs args, <span class="keyword">final</span> <span class="keyword">int</span> currentStatus)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Queue up an async operation since the package installation may take a little while.</span></span><br><span class="line">        mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">                    <span class="comment">// args是FileInstallArgs</span></span><br><span class="line">                    args.doPreInstall(res.returnCode);</span><br><span class="line">                    <span class="keyword">synchronized</span> (mInstallLock) &#123;</span><br><span class="line">                        installPackageTracedLI(args, res);</span><br><span class="line">                    &#125;</span><br><span class="line">                    args.doPostInstall(res.returnCode, res.uid);</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> (res.returnCode == PackageManager.INSTALL_SUCCEEDED &amp;&amp; doRestore) &#123;</span><br><span class="line">                    IBackupManager bm = IBackupManager.Stub.asInterface(</span><br><span class="line">                            ServiceManager.getService(Context.BACKUP_SERVICE));</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="comment">// 备份，备份之后会流转回到PKMS的handlePackagePostInstall方法，该方法中会发送Intent.ACTION_PACKAGE_ADDED广播，自此安装完毕</span></span><br><span class="line">                    bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token);</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installPackageTracedLI</span><span class="params">(InstallArgs args, PackageInstalledInfo res)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    installPackageLI(args, res);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installPackageLI</span><span class="params">(InstallArgs args, PackageInstalledInfo res)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    PackageParser pp = <span class="keyword">new</span> PackageParser();</span><br><span class="line">    <span class="keyword">final</span> PackageParser.Package pkg;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 重点: 解析安装包</span></span><br><span class="line">        pkg = pp.parsePackage(tmpPackageFile, parseFlags);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageParserException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!forwardLocked &amp;&amp; !pkg.applicationInfo.isExternalAsec()) &#123;</span><br><span class="line">        ... <span class="comment">// dexopt dex优化操作</span></span><br><span class="line">        mPackageDexOptimizer.performDexOpt(pkg, pkg.usesLibraryFiles,</span><br><span class="line">                <span class="keyword">null</span> <span class="comment">/* instructionSets */</span>, <span class="keyword">false</span> <span class="comment">/* checkProfiles */</span>,</span><br><span class="line">                getCompilerFilterForReason(REASON_INSTALL),</span><br><span class="line">                getOrCreateCompilerPackageStats(pkg));</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (replace) &#123; <span class="comment">// 更新, 最终会进入replaceNonSystemPackageLIF方法替换成新包，本次主要讲新安装</span></span><br><span class="line">        replacePackageLIF(pkg, parseFlags, scanFlags | SCAN_REPLACING, args.user,</span><br><span class="line">                installerPackageName, res);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 新安装</span></span><br><span class="line">        installNewPackageLIF(pkg, parseFlags, scanFlags | SCAN_DELETE_DATA_ON_FAILURES,</span><br><span class="line">                args.user, installerPackageName, volumeUuid, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="PackageParser"><a href="#PackageParser" class="headerlink" title="PackageParser"></a>PackageParser</h3><p>拷贝apk文件之后，进入PKMS.installPackageLI方法，这个方法内主要是两个步骤，第一个是解析apk包，第二步是安装，安装分为更新和新安装，这里主要分析新安装。installPackageLI方法执行完毕后面会执行bm.restoreAtInstall备份，备份之后会流转回到PKMS的handlePackagePostInstall方法，该方法中会发送Intent.ACTION_PACKAGE_ADDED广播，自此安装完毕。先看看解析apk这一步，来到PackageParser.parsePackage()方法：<br><figure class="highlight java"><figcaption><span>PackageParser.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Package <span class="title">parsePackage</span><span class="params">(File packageFile, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> PackageParserException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (packageFile.isDirectory()) &#123; <span class="comment">// 多个apk文件的解析,内部也是一个一个的解析的，这里不做主要分析</span></span><br><span class="line">        <span class="keyword">return</span> parseClusterPackage(packageFile, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 单个apk文件的解析</span></span><br><span class="line">        <span class="keyword">return</span> parseMonolithicPackage(packageFile, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Package <span class="title">parseMonolithicPackage</span><span class="params">(File apkFile, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> PackageParserException </span>&#123;</span><br><span class="line">    <span class="comment">// parseMonolithicPackageLite方法主要解析AndroidManifest.xml中installLocation、versionCode、versionName和&lt;manifest&gt;标签以外的内容</span></span><br><span class="line">    <span class="keyword">final</span> PackageLite lite = parseMonolithicPackageLite(apkFile, flags);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> AssetManager assets = <span class="keyword">new</span> AssetManager();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 解析&lt;manifest&gt;标签以内的未解析的内容</span></span><br><span class="line">        <span class="keyword">final</span> Package pkg = parseBaseApk(apkFile, assets, flags);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Package <span class="title">parseBaseApk</span><span class="params">(File apkFile, AssetManager assets, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> PackageParserException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> Package pkg = parseBaseApk(res, parser, flags, outError);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Package <span class="title">parseBaseApk</span><span class="params">(Resources res, XmlResourceParser parser, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">            String[] outError)</span> <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> parseBaseApkCommon(pkg, <span class="keyword">null</span>, res, parser, flags, outError);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>PackageParse内部经过流转，最终进入parseBaseApkCommon方法，解析AndroidManifest.xml文件：<br><figure class="highlight java"><figcaption><span>PackageParser.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Package <span class="title">parseBaseApkCommon</span><span class="params">(Package pkg, Set&lt;String&gt; acceptedTags, Resources res,</span></span></span><br><span class="line"><span class="function"><span class="params">            XmlResourceParser parser, <span class="keyword">int</span> flags, String[] outError)</span> <span class="keyword">throws</span> XmlPullParserException,</span></span><br><span class="line"><span class="function">            IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> outerDepth = parser.getDepth();</span><br><span class="line">    <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">            &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tagName.equals(TAG_APPLICATION)) &#123; <span class="comment">// application tag解析</span></span><br><span class="line">            <span class="keyword">if</span> (!parseBaseApplication(pkg, res, parser, flags, outError)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(...) &#123; <span class="comment">// 除application tag以外的全部tag的解析，overlay、keyset、permission、user-feature等等</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">parseBaseApplication</span><span class="params">(Package owner, Resources res,</span></span></span><br><span class="line"><span class="function"><span class="params">            XmlResourceParser parser, <span class="keyword">int</span> flags, String[] outError)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">    ... <span class="comment">// 解析application标签的属性值，theme、allowBackup等等所以的属性</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> innerDepth = parser.getDepth();</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">            &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tagName.equals(<span class="string">"activity"</span>)) &#123; <span class="comment">// 解析activity</span></span><br><span class="line">            Activity a = parseActivity(owner, res, parser, flags, outError, <span class="keyword">false</span>,</span><br><span class="line">                    owner.baseHardwareAccelerated);</span><br><span class="line">            ...</span><br><span class="line">            owner.activities.add(a);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">"receiver"</span>)) &#123; <span class="comment">// receiver跟activity一样调用的parseActivity方法</span></span><br><span class="line">            Activity a = parseActivity(owner, res, parser, flags, outError, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            ...</span><br><span class="line">            owner.receivers.add(a);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">"service"</span>)) &#123;</span><br><span class="line">            Service s = parseService(owner, res, parser, flags, outError);</span><br><span class="line">            ...</span><br><span class="line">            owner.services.add(s);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">"provider"</span>)) &#123;</span><br><span class="line">            Provider p = parseProvider(owner, res, parser, flags, outError);</span><br><span class="line">            ...</span><br><span class="line">            owner.providers.add(p);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(...) &#123; <span class="comment">// 其它标签，activity-alias、meta-data、library等等</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="dexopt"><a href="#dexopt" class="headerlink" title="dexopt"></a>dexopt</h2><p>上述源码，描述的就是解析AndroidManifest.xml文件的过程，解析之后，系统就保存了该apk内部的组件信息。接下来的一步就是dexOpt了，优化dex操作，是安装apk中比较重要的一个步骤：</p><h3 id="PackageDexOptimizer"><a href="#PackageDexOptimizer" class="headerlink" title="PackageDexOptimizer"></a>PackageDexOptimizer</h3><figure class="highlight java"><figcaption><span>PackageDexOptimizer.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">performDexOpt</span><span class="params">(PackageParser.Package pkg, String[] sharedLibraries,</span></span></span><br><span class="line"><span class="function"><span class="params">            String[] instructionSets, <span class="keyword">boolean</span> checkProfiles, String targetCompilationFilter,</span></span></span><br><span class="line"><span class="function"><span class="params">            CompilerStats.PackageStats packageStats)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mInstallLock) &#123;</span><br><span class="line">        <span class="keyword">return</span> performDexOptLI(pkg, sharedLibraries, instructionSets, checkProfiles,  </span><br><span class="line">                        targetCompilationFilter, packageStats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">performDexOptLI</span><span class="params">(PackageParser.Package pkg, String[] sharedLibraries,</span></span></span><br><span class="line"><span class="function"><span class="params">            String[] targetInstructionSets, <span class="keyword">boolean</span> checkProfiles, String targetCompilerFilter,</span></span></span><br><span class="line"><span class="function"><span class="params">            CompilerStats.PackageStats packageStats)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> String[] dexCodeInstructionSets = getDexCodeInstructionSets(instructionSets);</span><br><span class="line">    <span class="keyword">for</span> (String dexCodeInstructionSet : dexCodeInstructionSets) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String path : paths) &#123;</span><br><span class="line">            ...</span><br><span class="line">            mInstaller.dexopt(path, sharedGid, pkg.packageName, dexCodeInstructionSet,</span><br><span class="line">                    dexoptNeeded, oatDir, dexFlags, targetCompilerFilter, pkg.volumeUuid,</span><br><span class="line">                    sharedLibrariesPath);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Installer"><a href="#Installer" class="headerlink" title="Installer"></a>Installer</h3><figure class="highlight java"><figcaption><span>Installer.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dexopt</span><span class="params">(String apkPath, <span class="keyword">int</span> uid, String pkgName, String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> dexoptNeeded, @Nullable String outputPath, <span class="keyword">int</span> dexFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">            String compilerFilter, String volumeUuid, String sharedLibraries)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InstallerException </span>&#123;</span><br><span class="line">    mInstaller.dexopt(apkPath, uid, pkgName, instructionSet, dexoptNeeded,</span><br><span class="line">            outputPath, dexFlags, compilerFilter, volumeUuid, sharedLibraries);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="InstallerConnection"><a href="#InstallerConnection" class="headerlink" title="InstallerConnection"></a>InstallerConnection</h3><figure class="highlight java"><figcaption><span>InstallerConnection.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dexopt</span><span class="params">(String apkPath, <span class="keyword">int</span> uid, String pkgName, String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> dexoptNeeded, String outputPath, <span class="keyword">int</span> dexFlags, String compilerFilter,</span></span></span><br><span class="line"><span class="function"><span class="params">            String volumeUuid, String sharedLibraries)</span> <span class="keyword">throws</span> InstallerException </span>&#123;</span><br><span class="line">    execute(<span class="string">"dexopt"</span>,</span><br><span class="line">            apkPath,</span><br><span class="line">            uid,</span><br><span class="line">            pkgName,</span><br><span class="line">            instructionSet,</span><br><span class="line">            dexoptNeeded,</span><br><span class="line">            outputPath,</span><br><span class="line">            dexFlags,</span><br><span class="line">            compilerFilter,</span><br><span class="line">            volumeUuid,</span><br><span class="line">            sharedLibraries);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String[] execute(String cmd, Object... args) <span class="keyword">throws</span> InstallerException &#123;</span><br><span class="line">    <span class="keyword">final</span> StringBuilder builder = <span class="keyword">new</span> StringBuilder(cmd);</span><br><span class="line">    ... <span class="comment">// 构建参数</span></span><br><span class="line">    <span class="keyword">final</span> String[] resRaw = transact(builder.toString()).split(<span class="string">" "</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> resRaw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">transact</span><span class="params">(String cmd)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!connect()) &#123; <span class="comment">// 连接socket</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!writeCommand(cmd)) &#123; <span class="comment">// 写入dexopt命令,执行优化</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/// reply</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> replyLength = readReply();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="native-commands-cpp"><a href="#native-commands-cpp" class="headerlink" title="native commands.cpp"></a>native commands.cpp</h3><p>上述流转最后进入到native层的commands.cpp文件(位于android 7.1源码中frameworks/native/cmds/installd/文件夹下)中的dexopt方法：<br><figure class="highlight c"><figcaption><span>++ commands.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dexopt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> params[DEXOPT_PARAM_COUNT])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dexopt(params[<span class="number">0</span>],                    <span class="comment">// apk_path</span></span><br><span class="line">                  atoi(params[<span class="number">1</span>]),              <span class="comment">// uid</span></span><br><span class="line">                  params[<span class="number">2</span>],                    <span class="comment">// pkgname</span></span><br><span class="line">                  params[<span class="number">3</span>],                    <span class="comment">// instruction_set</span></span><br><span class="line">                  atoi(params[<span class="number">4</span>]),              <span class="comment">// dexopt_needed</span></span><br><span class="line">                  params[<span class="number">5</span>],                    <span class="comment">// oat_dir</span></span><br><span class="line">                  atoi(params[<span class="number">6</span>]),              <span class="comment">// dexopt_flags</span></span><br><span class="line">                  params[<span class="number">7</span>],                    <span class="comment">// compiler_filter</span></span><br><span class="line">                  parse_null(params[<span class="number">8</span>]),        <span class="comment">// volume_uuid</span></span><br><span class="line">                  parse_null(params[<span class="number">9</span>]));       <span class="comment">// shared_libraries</span></span><br><span class="line">    <span class="keyword">static_assert</span>(DEXOPT_PARAM_COUNT == <span class="number">10U</span>, <span class="string">"Unexpected dexopt param count"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dexopt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* apk_path, <span class="keyword">uid_t</span> uid, <span class="keyword">const</span> <span class="keyword">char</span>* pkgname, <span class="keyword">const</span> <span class="keyword">char</span>* instruction_set,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> dexopt_needed, <span class="keyword">const</span> <span class="keyword">char</span>* oat_dir, <span class="keyword">int</span> dexopt_flags, <span class="keyword">const</span> <span class="keyword">char</span>* compiler_filter,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> <span class="keyword">char</span>* volume_uuid ATTRIBUTE_UNUSED, <span class="keyword">const</span> <span class="keyword">char</span>* shared_libraries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> is_public = ((dexopt_flags &amp; DEXOPT_PUBLIC) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">bool</span> vm_safe_mode = (dexopt_flags &amp; DEXOPT_SAFEMODE) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> debuggable = (dexopt_flags &amp; DEXOPT_DEBUGGABLE) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> boot_complete = (dexopt_flags &amp; DEXOPT_BOOTCOMPLETE) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> profile_guided = (dexopt_flags &amp; DEXOPT_PROFILE_GUIDED) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't use profile for vm_safe_mode. b/30688277</span></span><br><span class="line">    profile_guided = profile_guided &amp;&amp; !vm_safe_mode;</span><br><span class="line"></span><br><span class="line">    CHECK(pkgname != <span class="literal">nullptr</span>);</span><br><span class="line">    CHECK(pkgname[<span class="number">0</span>] != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Public apps should not be compiled with profile information ever. Same goes for the special</span></span><br><span class="line">    <span class="comment">// package '*' used for the system server.</span></span><br><span class="line">    Dex2oatFileWrapper&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">void</span> ()&gt;&gt; reference_profile_fd;</span><br><span class="line">    <span class="keyword">if</span> (!is_public &amp;&amp; pkgname[<span class="number">0</span>] != <span class="string">'*'</span>) &#123;</span><br><span class="line">        <span class="comment">// Open reference profile in read only mode as dex2oat does not get write permissions.</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">pkgname_str</span><span class="params">(pkgname)</span></span>;</span><br><span class="line">        reference_profile_fd.reset(open_reference_profile(uid, pkgname, <span class="comment">/*read_write*/</span> <span class="literal">false</span>),</span><br><span class="line">                                   [pkgname_str]() &#123;</span><br><span class="line">                                       clear_reference_profile(pkgname_str.c_str());</span><br><span class="line">                                   &#125;);</span><br><span class="line">        <span class="comment">// Note: it's OK to not find a profile here.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((dexopt_flags &amp; ~DEXOPT_MASK) != <span class="number">0</span>) &#123;</span><br><span class="line">        LOG_FATAL(<span class="string">"dexopt flags contains unknown fields\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> out_path[PKG_PATH_MAX];</span><br><span class="line">    <span class="keyword">if</span> (!create_oat_out_path(apk_path, instruction_set, oat_dir, out_path)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *input_file;</span><br><span class="line">    <span class="keyword">char</span> in_odex_path[PKG_PATH_MAX];</span><br><span class="line">    <span class="keyword">switch</span> (dexopt_needed) &#123;</span><br><span class="line">        <span class="keyword">case</span> DEXOPT_DEX2OAT_NEEDED:</span><br><span class="line">            input_file = apk_path;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DEXOPT_PATCHOAT_NEEDED:</span><br><span class="line">            <span class="keyword">if</span> (!calculate_odex_file_path(in_odex_path, apk_path, instruction_set)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            input_file = in_odex_path;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DEXOPT_SELF_PATCHOAT_NEEDED:</span><br><span class="line">            input_file = out_path;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ALOGE(<span class="string">"Invalid dexopt needed: %d\n"</span>, dexopt_needed);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">72</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">input_stat</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;input_stat, <span class="number">0</span>, <span class="keyword">sizeof</span>(input_stat));</span><br><span class="line">    stat(input_file, &amp;input_stat);</span><br><span class="line"></span><br><span class="line">    base::<span class="function">unique_fd <span class="title">input_fd</span><span class="params">(open(input_file, O_RDONLY, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (input_fd.get() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"installd cannot open '%s' for input during dexopt\n"</span>, input_file);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">out_path_str</span><span class="params">(out_path)</span></span>;</span><br><span class="line">    Dex2oatFileWrapper&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">void</span> ()&gt;&gt; out_fd(</span><br><span class="line">            open_output_file(out_path, <span class="comment">/*recreate*/</span><span class="literal">true</span>, <span class="comment">/*permissions*/</span><span class="number">0644</span>),</span><br><span class="line">            [out_path_str]() &#123; unlink(out_path_str.c_str()); &#125;);</span><br><span class="line">    <span class="keyword">if</span> (out_fd.get() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"installd cannot open '%s' for output during dexopt\n"</span>, out_path);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!set_permissions_and_ownership(out_fd.get(), is_public, uid, out_path)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a swap file if necessary.</span></span><br><span class="line">    base::unique_fd swap_fd;</span><br><span class="line">    <span class="keyword">if</span> (ShouldUseSwapFileForDexopt()) &#123;</span><br><span class="line">        <span class="comment">// Make sure there really is enough space.</span></span><br><span class="line">        <span class="keyword">char</span> swap_file_name[PKG_PATH_MAX];</span><br><span class="line">        <span class="built_in">strcpy</span>(swap_file_name, out_path);</span><br><span class="line">        <span class="keyword">if</span> (add_extension_to_file_name(swap_file_name, <span class="string">".swap"</span>)) &#123;</span><br><span class="line">            swap_fd.reset(open_output_file(swap_file_name, <span class="comment">/*recreate*/</span><span class="literal">true</span>, <span class="comment">/*permissions*/</span><span class="number">0600</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (swap_fd.get() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Could not create swap file. Optimistically go on and hope that we can compile</span></span><br><span class="line">            <span class="comment">// without it.</span></span><br><span class="line">            ALOGE(<span class="string">"installd could not create '%s' for swap during dexopt\n"</span>, swap_file_name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Immediately unlink. We don't really want to hit flash.</span></span><br><span class="line">            <span class="keyword">if</span> (unlink(swap_file_name) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                PLOG(ERROR) &lt;&lt; <span class="string">"Couldn't unlink swap file "</span> &lt;&lt; swap_file_name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Avoid generating an app image for extract only since it will not contain any classes.</span></span><br><span class="line">    Dex2oatFileWrapper&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">void</span> ()&gt;&gt; image_fd;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> image_path = create_image_filename(out_path);</span><br><span class="line">    <span class="keyword">if</span> (!image_path.empty()) &#123;</span><br><span class="line">        <span class="keyword">char</span> app_image_format[kPropertyValueMax];</span><br><span class="line">        <span class="keyword">bool</span> have_app_image_format =</span><br><span class="line">                get_property(<span class="string">"dalvik.vm.appimageformat"</span>, app_image_format, <span class="literal">NULL</span>) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Use app images only if it is enabled (by a set image format) and we are compiling</span></span><br><span class="line">        <span class="comment">// profile-guided (so the app image doesn't conservatively contain all classes).</span></span><br><span class="line">        <span class="keyword">if</span> (profile_guided &amp;&amp; have_app_image_format) &#123;</span><br><span class="line">            <span class="comment">// Recreate is true since we do not want to modify a mapped image. If the app is</span></span><br><span class="line">            <span class="comment">// already running and we modify the image file, it can cause crashes (b/27493510).</span></span><br><span class="line">            image_fd.reset(open_output_file(image_path.c_str(),</span><br><span class="line">                                            <span class="literal">true</span> <span class="comment">/*recreate*/</span>,</span><br><span class="line">                                            <span class="number">0600</span> <span class="comment">/*permissions*/</span>),</span><br><span class="line">                           [image_path]() &#123; unlink(image_path.c_str()); &#125;</span><br><span class="line">                           );</span><br><span class="line">            <span class="keyword">if</span> (image_fd.get() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Could not create application image file. Go on since we can compile without</span></span><br><span class="line">                <span class="comment">// it.</span></span><br><span class="line">                LOG(ERROR) &lt;&lt; <span class="string">"installd could not create '"</span></span><br><span class="line">                        &lt;&lt; image_path</span><br><span class="line">                        &lt;&lt; <span class="string">"' for image file during dexopt"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!set_permissions_and_ownership(image_fd.get(),</span><br><span class="line">                                                      is_public,</span><br><span class="line">                                                      uid,</span><br><span class="line">                                                      image_path.c_str())) &#123;</span><br><span class="line">                image_fd.reset(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If we have a valid image file path but no image fd, explicitly erase the image file.</span></span><br><span class="line">        <span class="keyword">if</span> (image_fd.get() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (unlink(image_path.c_str()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno != ENOENT) &#123;</span><br><span class="line">                    PLOG(ERROR) &lt;&lt; <span class="string">"Couldn't unlink image file "</span> &lt;&lt; image_path;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"DexInv: --- BEGIN '%s' ---\n"</span>, input_file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* child -- drop privileges before continuing */</span></span><br><span class="line">        drop_capabilities(uid);</span><br><span class="line"></span><br><span class="line">        SetDex2OatAndPatchOatScheduling(boot_complete);</span><br><span class="line">        <span class="keyword">if</span> (flock(out_fd.get(), LOCK_EX | LOCK_NB) != <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"flock(%s) failed: %s\n"</span>, out_path, strerror(errno));</span><br><span class="line">            _exit(<span class="number">67</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dexopt_needed == DEXOPT_PATCHOAT_NEEDED</span><br><span class="line">            || dexopt_needed == DEXOPT_SELF_PATCHOAT_NEEDED) &#123;</span><br><span class="line">            run_patchoat(input_fd.get(),</span><br><span class="line">                         out_fd.get(),</span><br><span class="line">                         input_file,</span><br><span class="line">                         out_path,</span><br><span class="line">                         pkgname,</span><br><span class="line">                         instruction_set);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dexopt_needed == DEXOPT_DEX2OAT_NEEDED) &#123;</span><br><span class="line">            <span class="comment">// Pass dex2oat the relative path to the input file.</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *input_file_name = get_location_from_path(input_file);</span><br><span class="line">            run_dex2oat(input_fd.get(),</span><br><span class="line">                        out_fd.get(),</span><br><span class="line">                        image_fd.get(),</span><br><span class="line">                        input_file_name,</span><br><span class="line">                        out_path,</span><br><span class="line">                        swap_fd.get(),</span><br><span class="line">                        instruction_set,</span><br><span class="line">                        compiler_filter,</span><br><span class="line">                        vm_safe_mode,</span><br><span class="line">                        debuggable,</span><br><span class="line">                        boot_complete,</span><br><span class="line">                        reference_profile_fd.get(),</span><br><span class="line">                        shared_libraries);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGE(<span class="string">"Invalid dexopt needed: %d\n"</span>, dexopt_needed);</span><br><span class="line">            _exit(<span class="number">73</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _exit(<span class="number">68</span>);   <span class="comment">/* only get here on exec failure */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> res = wait_child(pid);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGV(<span class="string">"DexInv: --- END '%s' (success) ---\n"</span>, input_file);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGE(<span class="string">"DexInv: --- END '%s' --- status=0x%04x, process failed\n"</span>, input_file, res);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">utimbuf</span> <span class="title">ut</span>;</span></span><br><span class="line">    ut.actime = input_stat.st_atime;</span><br><span class="line">    ut.modtime = input_stat.st_mtime;</span><br><span class="line">    utime(out_path, &amp;ut);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We've been successful, don't delete output.</span></span><br><span class="line">    out_fd.SetCleanup(<span class="literal">false</span>);</span><br><span class="line">    image_fd.SetCleanup(<span class="literal">false</span>);</span><br><span class="line">    reference_profile_fd.SetCleanup(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>dexopt步骤具体实现这里不做分析，我也不太懂，超出了本文的分析范围。接下来继续上一步的installNewPackageLIF方法安装新的apk包：<br><figure class="highlight java"><figcaption><span>PackageManagerService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Install a non-existing package.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installNewPackageLIF</span><span class="params">(PackageParser.Package pkg, <span class="keyword">final</span> <span class="keyword">int</span> policyFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> scanFlags, UserHandle user, String installerPackageName, String volumeUuid,</span></span></span><br><span class="line"><span class="function"><span class="params">        PackageInstalledInfo res)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 这步主要是创建新app的一些系统设置信息，</span></span><br><span class="line">        PackageParser.Package newPackage = scanPackageTracedLI(pkg, policyFlags, scanFlags,</span><br><span class="line">                System.currentTimeMillis(), user);</span><br><span class="line">        <span class="comment">// update settings and permissions</span></span><br><span class="line">        updateSettingsLI(newPackage, installerPackageName, <span class="keyword">null</span>, res, user);</span><br><span class="line">        <span class="keyword">if</span> (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">            prepareAppDataAfterInstallLIF(newPackage); <span class="comment">// 安装成功准备数据</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 安装失败会删除package</span></span><br><span class="line">            deletePackageLIF(pkgName, UserHandle.ALL, <span class="keyword">false</span>, <span class="keyword">null</span>,</span><br><span class="line">                    PackageManager.DELETE_KEEP_DATA, res.removedInfo, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManagerException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法完成权限、设置、数据等步骤之后，安装的步骤完成，会继续执行上面提到的备份步骤，备份完成之后，发送Intent.ACTION_PACKAGE_ADDED广播，完成安装。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>跟踪完了这么多的源码，可能脑子已经糊涂了，我们再理一下整个过程的大体步骤：</p><ol><li>点击apk文件弹出安装，即PackageInstaller.app应用中的处理</li><li>进入PackageInstaller、PackageInstallerSession等类的处理</li><li>进入PKMS.installStage方法</li><li>PKMS.handleStartCopy()拷贝apk文件到/data/app目录下</li><li>开始解析安装包，PackageParse类的流转</li><li>dexopt</li><li>dexopt完成就是数据、权限、设置等信息的完善</li><li>备份</li><li>安装完成</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/huangzhengneng/ImageFactory/raw/master/blog/app_install_flow_cover.jpeg&quot; alt=&quot;app_install_flow&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="source analysis" scheme="http://yoursite.com/tags/source-analysis/"/>
    
  </entry>
  
  <entry>
    <title>Binder&amp;AIDL入门</title>
    <link href="http://yoursite.com/2019/01/08/Binder-AIDL%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/01/08/Binder-AIDL入门/</id>
    <published>2019-01-08T01:58:14.000Z</published>
    <updated>2019-11-21T03:11:22.410Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/binder_aidl_cover.jpeg" alt="binder_aidl_cover"></p><hr><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Binder是Android中一种独有的跨进程通信(IPC)方式，Binder的出现解决了传统Linux跨进程通信方式的效率和安全问题，传统Linux跨进程通信方式也有不少，包括管道、System V IPC(即共享内存、消息队列、信号量)、Socket等，但都存在效率或者安全问题，因此Android自己创造了Binder，来解决上述问题。可以毫不夸张地说Binder是Android系统中最重要的特性之一，它几乎无处不在，是各个组件的桥梁，理解Binder对后续理解Android系统其它原理必不可少，本篇介绍Binder的基本原理以及Binder的延伸AIDL。</p><h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>Binder存在于Android系统中几乎所有地方，四大组件的启动全都是借力于Binder机制。<br>Binder结构基于C/S架构，有四个主要角色：Server、Client、ServiceManager(以下简称SM)、Binder Driver，下图描述一次Binder IPC主要步骤：<br><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/binder_communication.png" alt="binder"></p><p>上图中的数字表示前后顺序，解释如下：</p><ol><li>Server进程向SM注册服务，ServiceManager将该Server存入查找表中</li><li>某Client进程向SM查询目标server</li><li>如果目标server在SM中注册过，就会返回一个引用，该引用是具有远程Server进程功能的代理对象,该对象能直接访问内核态的Binder驱动</li><li>通过3获取的proxy对象告诉binder驱动需要调用server的方法</li><li>binder驱动通过真实binder对象调用server进程的方法</li><li>server进程返回结果给binder驱动</li><li>binder驱动将结果返回给client</li></ol><p>以上步骤，binder驱动出了很多力，binder驱动内部原理涉及太多native知识，这里就不介绍了。<br>细心的人也许会发现，上面的步骤一其实也是跨进程通信，server进程和SM进程是不同的进程，这里就出现了鸡蛋孵出小鸡，又需要一只生蛋的鸡了，binder的实现是预先创建一只鸡来生蛋，SM和所有的其它需要注册服务的进程一样使用binder通信，SM是Server，有自己的binder对象，这个对象没有名字，也不需要注册，其它进程是Client。</p><h2 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h2><p>AIDL是Binder的延伸，因此先介绍完binder的基本原理，再介绍AIDL，在Android系统中有很多服务都是AIDL，比如粘贴板、包管理器等等。</p><p>先来写一个简单的AIDLDemo。</p><h3 id="AIDLDemo"><a href="#AIDLDemo" class="headerlink" title="AIDLDemo"></a>AIDLDemo</h3><h4 id="1-第一步创建一个实体类Person-并且需要实现Parcelable接口，用于IPC过程数据持久化："><a href="#1-第一步创建一个实体类Person-并且需要实现Parcelable接口，用于IPC过程数据持久化：" class="headerlink" title="1. 第一步创建一个实体类Person, 并且需要实现Parcelable接口，用于IPC过程数据持久化："></a>1. 第一步创建一个实体类Person, 并且需要实现Parcelable接口，用于IPC过程数据持久化：</h4><figure class="highlight java"><figcaption><span>Person.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hzn.aidldemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Parcel;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcelable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by yfax-android-zhengneng at 04/01/2019</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123; <span class="comment">// 实现Parcelable接口，支持数据持久化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Person</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        name = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;Person&gt; CREATOR = <span class="keyword">new</span> Creator&lt;Person&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Person[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person &#123; name: "</span> + name + <span class="string">" &#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-第二步创建aidl文件夹，并且创建Person-aidl文件，这个文件必须与上面Person实体的包名类名一致："><a href="#2-第二步创建aidl文件夹，并且创建Person-aidl文件，这个文件必须与上面Person实体的包名类名一致：" class="headerlink" title="2. 第二步创建aidl文件夹，并且创建Person.aidl文件，这个文件必须与上面Person实体的包名类名一致："></a>2. 第二步创建aidl文件夹，并且创建Person.aidl文件，这个文件必须与上面Person实体的包名类名一致：</h4><figure class="highlight java"><figcaption><span>Person.aidl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hzn.aidldemo;</span><br><span class="line"></span><br><span class="line">parcelable Person;</span><br></pre></td></tr></table></figure><h4 id="3-第三步，创建aidlInterface接口-在接口中定义2个方法，这两个方法就是Server进程想暴露给其它进程的功能，其它进程可以通过binder访问到这两个方法："><a href="#3-第三步，创建aidlInterface接口-在接口中定义2个方法，这两个方法就是Server进程想暴露给其它进程的功能，其它进程可以通过binder访问到这两个方法：" class="headerlink" title="3. 第三步，创建aidlInterface接口, 在接口中定义2个方法，这两个方法就是Server进程想暴露给其它进程的功能，其它进程可以通过binder访问到这两个方法："></a>3. 第三步，创建aidlInterface接口, 在接口中定义2个方法，这两个方法就是Server进程想暴露给其它进程的功能，其它进程可以通过binder访问到这两个方法：</h4><figure class="highlight java"><figcaption><span>IMyAidlInterface.aidl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hzn.aidldemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hzn.aidldemo.Person; <span class="comment">// 导入实体类的全路径</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> </span>&#123; <span class="comment">// 定义2个Server端想提供给client端调用的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 除了基本数据类型，其他类型的参数都需要标上方向类型：in(输入), out(输出), inout(输入输出)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addPerson</span><span class="params">(in Person person)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Person&gt; <span class="title">getPersonList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-第四步build一下工程，build完成之后会在build-generated-source-aidl-debug-下生成IMyAidlInterface-java文件："><a href="#4-第四步build一下工程，build完成之后会在build-generated-source-aidl-debug-下生成IMyAidlInterface-java文件：" class="headerlink" title="4. 第四步build一下工程，build完成之后会在build/generated/source/aidl/debug/..下生成IMyAidlInterface.java文件："></a>4. 第四步build一下工程，build完成之后会在build/generated/source/aidl/debug/..下生成IMyAidlInterface.java文件：</h4><figure class="highlight java"><figcaption><span>IMyAidlInterface.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This file is auto-generated.  DO NOT MODIFY.</span></span><br><span class="line"><span class="comment"> * Original file: /Users/yfax-android-zhengneng/Documents/dev/codes/android/AIDLDemo/app/src/main/aidl/com/hzn/aidldemo/IMyAidlInterface.aidl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.hzn.aidldemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Local-side IPC implementation stub class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">hzn</span>.<span class="title">aidldemo</span>.<span class="title">IMyAidlInterface</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.hzn.aidldemo.IMyAidlInterface"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Construct the stub at attach it to the interface.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Cast an IBinder object into an com.hzn.aidldemo.IMyAidlInterface interface,</span></span><br><span class="line"><span class="comment">         * generating a proxy if needed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.hzn.aidldemo.<span class="function">IMyAidlInterface <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.hzn.aidldemo.IMyAidlInterface))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((com.hzn.aidldemo.IMyAidlInterface) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> com.hzn.aidldemo.IMyAidlInterface.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_addPerson: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    com.hzn.aidldemo.Person _arg0;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">                        _arg0 = com.hzn.aidldemo.Person.CREATOR.createFromParcel(data);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _arg0 = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">this</span>.addPerson(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_getPersonList: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    java.util.List&lt;com.hzn.aidldemo.Person&gt; _result = <span class="keyword">this</span>.getPersonList();</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeTypedList(_result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">hzn</span>.<span class="title">aidldemo</span>.<span class="title">IMyAidlInterface</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 除了基本数据类型，其他类型的参数都需要标上方向类型：in(输入), out(输出), inout(输入输出)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPerson</span><span class="params">(com.hzn.aidldemo.Person person)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">if</span> ((person != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">1</span>);</span><br><span class="line">                        person.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_addPerson, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> java.util.List&lt;com.hzn.aidldemo.Person&gt; getPersonList() <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                java.util.List&lt;com.hzn.aidldemo.Person&gt; _result;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_getPersonList, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.createTypedArrayList(com.hzn.aidldemo.Person.CREATOR);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addPerson = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getPersonList = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 除了基本数据类型，其他类型的参数都需要标上方向类型：in(输入), out(输出), inout(输入输出)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPerson</span><span class="params">(com.hzn.aidldemo.Person person)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.util.List&lt;com.hzn.aidldemo.Person&gt; getPersonList() <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生成的MyAidlInterface.java类是核心，后面介绍。</strong></p><h4 id="5-第五步，创建另一个进程下的Service，作为Server进程："><a href="#5-第五步，创建另一个进程下的Service，作为Server进程：" class="headerlink" title="5. 第五步，创建另一个进程下的Service，作为Server进程："></a>5. 第五步，创建另一个进程下的Service，作为Server进程：</h4><figure class="highlight java"><figcaption><span>MyService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hzn.aidldemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Service;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyService"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Person&gt; mPerson;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IBinder mIBinder = <span class="keyword">new</span> IMyAidlInterface.Stub() &#123; <span class="comment">// 这里就是Server端的具体实现，client端调用的方法最终执行到这里</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPerson</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">            mPerson.add(person);</span><br><span class="line">            Log.i(TAG, <span class="string">"add person: "</span> + person.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">getPersonList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.i(TAG, <span class="string">"get all person list : "</span> + mPerson.toString());</span><br><span class="line">            <span class="keyword">return</span> mPerson;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        mPerson = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> mIBinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AndroidManifest.xml注册为：</span><br><span class="line">    &lt;service</span><br><span class="line">        android:name=<span class="string">".MyService"</span></span><br><span class="line">        android:enabled=<span class="string">"true"</span></span><br><span class="line">        android:exported=<span class="string">"true"</span></span><br><span class="line">        android:process=<span class="string">".aidl"</span>/&gt; <span class="comment">// MyService在独立进程，与MainActivity所在的client不在一进程,因此互相调用就是跨进程通信</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-第六步，在Activity中创建ServiceConnection，用来绑定service，调用远程server的方法："><a href="#6-第六步，在Activity中创建ServiceConnection，用来绑定service，调用远程server的方法：" class="headerlink" title="6. 第六步，在Activity中创建ServiceConnection，用来绑定service，调用远程server的方法："></a>6. 第六步，在Activity中创建ServiceConnection，用来绑定service，调用远程server的方法：</h4><figure class="highlight java"><figcaption><span>MainActivity.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.hzn.aidldemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ComponentName;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.ServiceConnection;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IMyAidlInterface myAidlInterface;</span><br><span class="line">    <span class="keyword">private</span> TextView textView;</span><br><span class="line">    <span class="keyword">private</span> Button button;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 获取Server端的代理对象，该代理对象持有能联系binder driver具有跨进程通信能力的binder引用</span></span><br><span class="line">            myAidlInterface = IMyAidlInterface.Stub.asInterface(service);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">            myAidlInterface = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        textView = findViewById(R.id.textview);</span><br><span class="line">        button = findViewById(R.id.button);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; <span class="comment">// 调用Server端的函数，返回结果，显示到client进程的UI界面上</span></span><br><span class="line">                    List&lt;Person&gt; personList = myAidlInterface.getPersonList();</span><br><span class="line">                    myAidlInterface.addPerson(<span class="keyword">new</span> Person(<span class="string">"people index "</span> + (personList == <span class="keyword">null</span> ? <span class="string">"0"</span> : personList.size())));</span><br><span class="line">                    personList = myAidlInterface.getPersonList();</span><br><span class="line">                    textView.setText(personList.toString());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 绑定service，获取iBinder对象,在当前项目中就是Server端的具体实现</span></span><br><span class="line">        bindService(<span class="keyword">new</span> Intent(getApplicationContext(), MyService<span class="class">.<span class="keyword">class</span>), <span class="title">connection</span>, <span class="title">BIND_AUTO_CREATE</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-运行后结果："><a href="#7-运行后结果：" class="headerlink" title="7. 运行后结果："></a>7. 运行后结果：</h4><p><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/aidl_demo.gif" alt="aidl_demo.gif"></p><h3 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h3><p>看完了上面的aidl简单demo，现在来一起看看这个过程是怎么运行起来的，中间出现的各种代码是什么意思？</p><p>AIDL中有几类非常重要：</p><ul><li>IBinder 实现该接口就具有跨进程通信的能力(就是连接binder driver的能力)</li><li>IInterface Server端提供的功能定义在这个接口中</li><li>Binder 实现了IBinder接口</li><li>Stub 继承了Binder又实现了IIterface接口的抽象类,server端持有的binder本地对象的抽象类</li><li>Proxy Stub的内部类，持有IBinder引用，能跨进程通信，就是client端持有的binder代理对象</li></ul><p>这些都在上面第四步生成的MyAidlInterface.java类中，代表的是什么意思？：</p><ul><li>IBinder是一个接口，只要实现了这个接口，就能将这个对象进行跨进程传递；这是binder driver支持的；在跨进程数据流经驱动的时候，驱动会识别IBinder类型的数据，从而自动完成不同进程Binder本地对象以及Binder代理对象的转换。</li><li>IBinder负责数据传输，IInterface代表的就是远程server对象具有什么能力。具体来说，就是aidl里面的接口。</li><li>Java层的Binder类，代表的其实就是Binder本地对象。BinderProxy类是Binder子类的一个内部类，它代表远程进程的Binder对象的本地代理；这两个类都继承自IBinder, 因而都具有跨进程传输的能力；</li><li>在使用AIDL的时候，编译工具会给我们生成一个Stub的静态内部类；这个类继承了Binder, 说明它是一个Binder本地对象，它实现了IInterface接口，表明它具有远程Server承诺给Client的能力；Stub是一个抽象类，具体的IInterface的相关实现需要我们手动完成，这里使用了策略模式。</li><li>整个通信的传递核心在IBinder，即binder driver的数据传递过程，这个过程在native实现，我们不需要深入去探究了，仅仅在java层了解原理就够了，如果你熟悉c、c++，可以到android源码的frameworks/native文件夹下寻找对应的binder driver实现…</li></ul><p>再根据上一节来解释步骤，先从客户端调用开始看，即第六步：<br><figure class="highlight java"><figcaption><span>MainActivity.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">private</span> IMyAidlInterface myAidlInterface;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Server端的代理对象，该代理对象持有能联系binder driver具有跨进程通信能力的binder引用</span></span><br><span class="line">        myAidlInterface = IMyAidlInterface.Stub.asInterface(service);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;<span class="comment">// 调用Server端的函数，返回结果，显示到client进程的UI界面上</span></span><br><span class="line">                List&lt;Person&gt; personList = myAidlInterface.getPersonList();</span><br><span class="line">                myAidlInterface.addPerson(<span class="keyword">new</span> Person(<span class="string">"people index "</span> + (personList == <span class="keyword">null</span> ? <span class="string">"0"</span> : personList.size())));</span><br><span class="line">                personList = myAidlInterface.getPersonList();</span><br><span class="line">                textView.setText(personList.toString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">     <span class="comment">// 绑定service，获取iBinder对象,在当前项目中就是Server端的具体实现</span></span><br><span class="line">    bindService(<span class="keyword">new</span> Intent(getApplicationContext(), MyService<span class="class">.<span class="keyword">class</span>), <span class="title">connection</span>, <span class="title">BIND_AUTO_CREATE</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>client端通过myAidlInterface对象调用远程server端的方法，myAidlInterface对象即MyAidlInterface实例，它实现了IInterface接口，因此具备server端的功能，myAidlInterface对象是IMyAidlInterface.Stub.asInterface(ibinder)方法返回：<br><figure class="highlight java"><figcaption><span>IMyAidlInterface.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cast an IBinder object into an com.hzn.aidldemo.IMyAidlInterface interface,</span></span><br><span class="line"><span class="comment"> * generating a proxy if needed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.hzn.aidldemo.<span class="function">IMyAidlInterface <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); <span class="comment">// 具体实现在Binder类中</span></span><br><span class="line">    <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.hzn.aidldemo.IMyAidlInterface))) &#123;</span><br><span class="line">        <span class="comment">// 非跨进程通信，之后强转为目标接口类型并返回</span></span><br><span class="line">        <span class="keyword">return</span> ((com.hzn.aidldemo.IMyAidlInterface) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跨进程通信，返回持有远程binder对象引用的代理对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> com.hzn.aidldemo.IMyAidlInterface.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法的参数obj，是MyService中onBind方法返回的ibinder对象，该对象就是Server端的具体实现：<br><figure class="highlight java"><figcaption><span>MyService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Person&gt; mPerson;</span><br><span class="line"><span class="keyword">private</span> IBinder mIBinder = <span class="keyword">new</span> IMyAidlInterface.Stub() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPerson</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        mPerson.add(person);</span><br><span class="line">        Log.i(TAG, <span class="string">"add person: "</span> + person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">getPersonList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"get all person list : "</span> + mPerson.toString());</span><br><span class="line">        <span class="keyword">return</span> mPerson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>asInterface方法中会先判断server进程跟client进程是否是同一进程，该判断的具体实现在Binder.java中，如果是同一进程，直接强转为IMyAidlInterface对象返回，后续就不涉及IPC了，如果不是同一进程，会新建一个Proxy对象返回给client，Proxy是Stub类的一个内部类，该类实现了IMyAidlInterface接口，也就间接实现了IInterface接口，该类持有Server端的具体实现iBinder引用，并且实现了相关方法：addPerson() 和 getPersonList()：<br><figure class="highlight java"><figcaption><span>IMyAidlInterface.Stub.Proxy</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 除了基本数据类型，其他类型的参数都需要标上方向类型：in(输入), out(输出), inout(输入输出)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPerson</span><span class="params">(com.hzn.aidldemo.Person person)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        <span class="keyword">if</span> ((person != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            _data.writeInt(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 把方法参数写入parcel中</span></span><br><span class="line">            person.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _data.writeInt(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用transact方法，第一个参数code用于标识调用的是哪个方法，_data用来传递参数，_replay用来接收结果</span></span><br><span class="line">        mRemote.transact(Stub.TRANSACTION_addPerson, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        _reply.readException();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> java.util.List&lt;com.hzn.aidldemo.Person&gt; getPersonList() <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    java.util.List&lt;com.hzn.aidldemo.Person&gt; _result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        <span class="comment">// 调用transact方法，第一个参数code用于标识调用的是哪个方法，_data用来传递参数，_replay用来接收结果</span></span><br><span class="line">        mRemote.transact(Stub.TRANSACTION_getPersonList, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        _reply.readException();</span><br><span class="line">        <span class="comment">// 从_reply中读取方法的返回结果,具体实现在Parcel.java中createTypedArrayList方法</span></span><br><span class="line">        _result = _reply.createTypedArrayList(com.hzn.aidldemo.Person.CREATOR);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>client端调用myAidlInterface的方法实现就在这里，可以看到是通过Parcel做的数据持久化，因此aidl通信的数据格式只支持普通数据类型和可以序列化的对象，接下来会调用mRemote.transact()方法，mRemote上面说了就是Stub的实现类的对象，因此直接找Stub类的transact方法，transact方法在Stub的父类Binder中，并且是final修饰：<br><figure class="highlight java"><figcaption><span>Binder.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Default implementation rewinds the parcels and calls onTransact.  On</span></span><br><span class="line"><span class="comment">    * the remote side, transact calls into the binder to do the IPC.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, @NonNull Parcel data, @Nullable Parcel reply,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> r = onTransact(code, data, reply, flags);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到transact方法内部调用了onTransact方法，Stub类复写了该方法：<br><figure class="highlight java"><figcaption><span>Binder.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123; <span class="comment">// 根据code判断调用哪个方法</span></span><br><span class="line">        <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">            reply.writeString(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_addPerson: &#123;</span><br><span class="line">            data.enforceInterface(DESCRIPTOR);</span><br><span class="line">            com.hzn.aidldemo.Person _arg0;</span><br><span class="line">            <span class="comment">// 读取参数</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">                _arg0 = com.hzn.aidldemo.Person.CREATOR.createFromParcel(data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _arg0 = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用具体执行的方法</span></span><br><span class="line">            <span class="keyword">this</span>.addPerson(_arg0);</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_getPersonList: &#123;</span><br><span class="line">            data.enforceInterface(DESCRIPTOR);</span><br><span class="line">            <span class="comment">// 调用具体执行的方法</span></span><br><span class="line">            java.util.List&lt;com.hzn.aidldemo.Person&gt; _result = <span class="keyword">this</span>.getPersonList();</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            <span class="comment">// 写入返回结果</span></span><br><span class="line">            reply.writeTypedList(_result);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体过程是根据code判断调用的具体方法，从Parcel中读取参数，并且调用对应方法，即MyService中的Stub具体实现，如果有返回值，会继续使用Parcel将返回值返回给client端，流程到这里就结束了，整个Binder IPC的过程就走完了，client调用了server的功能，实现了两个进程的通信。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看完了binder和aidl的入门知识，基本原理，现在再回过头来看一下activity的启动过程，AMS、IActivityManager、ActivityManagerNative、ActivityManagerProxy这几个类的关系就很清晰了，IActivityManager即继承了IIterface的接口，具有server的功能，ActivityManagerProxy是ActivityManagerNative的内部类，AMS是ActivityManagerNative的实现类，这跟AIDL模型一样，所有转发到ActivityManagerNative的功能，都会在AMS中实现。</p><p>binder&amp;aidl入门和基本原理就记录到这里，后续会在其它android系统原理相关的文章中大量涉及binder&amp;aidl，因此弄懂基本原理非常重要。</p><p>参考文章：<br><a href="http://www.cnblogs.com/Jax/p/6864103.html" target="_blank" rel="noopener">写给Android App开发人员看的Android底层知识（1）</a><br><a href="http://weishu.me/2016/01/12/binder-index-for-newer/" target="_blank" rel="noopener">Binder学习指南</a><br><a href="https://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">Android-Binder设计与实现</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/huangzhengneng/ImageFactory/raw/master/blog/binder_aidl_cover.jpeg&quot; alt=&quot;binder_aidl_cover&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android-Activity启动流程分析</title>
    <link href="http://yoursite.com/2018/12/21/Android-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/12/21/Android-Activity启动流程分析/</id>
    <published>2018-12-21T02:34:29.000Z</published>
    <updated>2019-11-21T03:11:22.409Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/activity_launch_flow_cover.jpeg" alt="activity_launcher_flow"></p><hr><a id="more"></a><h3 id="Activity启动流程"><a href="#Activity启动流程" class="headerlink" title="Activity启动流程"></a>Activity启动流程</h3><p>本文将从startActivity方法开始分析启动一个Activity的流程，包括当前Activity#onPause() -&gt; TargetActivity#onResume()整个流程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文基于Android 7.1.0 api25源码分析</span><br></pre></td></tr></table></figure></p><p>我们都知道Android中启动Activity都是通过Context.startActivity()方法执行的，先看看Context类及主要实现类的继承结构：<br><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/context_extends_structure.png" alt="context_extends_structure"></p><h4 id="context-startActivity-amp-amp-Activity-startActivity-的区别"><a href="#context-startActivity-amp-amp-Activity-startActivity-的区别" class="headerlink" title="context.startActivity() &amp;&amp; Activity.startActivity()的区别"></a>context.startActivity() &amp;&amp; Activity.startActivity()的区别</h4><p>我们一般启动Activity主要分两种，一种是直接调用context.startActivity()方法，另一种是在Activity中调用startActivity()方法，看看两者区别：<br><figure class="highlight java"><figcaption><span>ContextImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mMainThread.getInstrumentation().execStartActivity(</span><br><span class="line">            getOuterContext(), mMainThread.getApplicationThread(), <span class="keyword">null</span>,</span><br><span class="line">            (Activity) <span class="keyword">null</span>, intent, -<span class="number">1</span>, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><figcaption><span>Activity.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.startActivity(intent, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">        startActivityForResult(intent, -<span class="number">1</span>, options);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        startActivityForResult(intent, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(Intent intent, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">    startActivityForResult(intent, requestCode, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(Intent intent, <span class="keyword">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Instrumentation.ActivityResult ar =</span><br><span class="line">            mInstrumentation.execStartActivity(</span><br><span class="line">                <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                intent, requestCode, options);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// mParent是Activity实例</span></span><br><span class="line">        <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode, options);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityFromChild</span><span class="params">(@NonNull Activity child, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    Instrumentation.ActivityResult ar =</span><br><span class="line">        mInstrumentation.execStartActivity(</span><br><span class="line">            <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, child,</span><br><span class="line">            intent, requestCode, options);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上ContextImpl.java和Activity.java两个类的startActivity()方法来看，可以发现最终都是调用了Instrumentation.execStartActivity()方法，只不过参数传入不同，Activity中可以传递requestCode和target参数用来交互，可以在onActivityResult()方法中接收返回回来的数据，而context.startActivity()没有这个功能</p><h4 id="Instrumentation-execStartActivity"><a href="#Instrumentation-execStartActivity" class="headerlink" title="Instrumentation.execStartActivity()"></a>Instrumentation.execStartActivity()</h4><p>接下来看看Instrumentation.execStartActivity()方法内部：</p><figure class="highlight java"><figcaption><span>Instrumentation.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">            Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">int</span> result = ActivityManagerNative.getDefault()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                    requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">        checkStartActivityResult(result, intent);<span class="comment">// 检查返回结果</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkStartActivityResult</span><span class="params">(<span class="keyword">int</span> res, Object intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (res &gt;= ActivityManager.START_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_INTENT_NOT_RESOLVED: <span class="comment">// intent异常</span></span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_CLASS_NOT_FOUND:</span><br><span class="line">            <span class="comment">// 最常见的异常之一，具体返回是在ActivityStarter.startActivityLocked方法中，因为ActivityInfo为空</span></span><br><span class="line">            <span class="keyword">if</span> (intent <span class="keyword">instanceof</span> Intent &amp;&amp; ((Intent)intent).getComponent() != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ActivityNotFoundException(</span><br><span class="line">                        <span class="string">"Unable to find explicit activity class "</span></span><br><span class="line">                        + ((Intent)intent).getComponent().toShortString()</span><br><span class="line">                        + <span class="string">"; have you declared this activity in your AndroidManifest.xml?"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ActivityNotFoundException(</span><br><span class="line">                    <span class="string">"No Activity found to handle "</span> + intent);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_PERMISSION_DENIED: <span class="comment">// 权限拒绝</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Not allowed to start activity "</span></span><br><span class="line">                    + intent);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT: <span class="comment">// 冲突</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(</span><br><span class="line">                    <span class="string">"FORWARD_RESULT_FLAG used while also requesting a result"</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_NOT_ACTIVITY: <span class="comment">// 目标类没有继承Activity</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"PendingIntent is not an activity"</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_NOT_VOICE_COMPATIBLE:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Starting under voice control not allowed for: "</span> + intent);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_VOICE_NOT_ACTIVE_SESSION:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Session calling startVoiceActivity does not match active session"</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_VOICE_HIDDEN_SESSION:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Cannot start voice activity on a hidden session"</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_CANCELED:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Activity could not be started for "</span></span><br><span class="line">                    + intent);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Unknown error code "</span></span><br><span class="line">                    + res + <span class="string">" when starting "</span> + intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>execStartActivity方法调用了ActivityManagerNative.getDefault().startActivity()方法，ActivityManagerNative.getDefault()方法返回的是ActivityManagerNative的内部类ActivityManagerProxy对象，ActivityManagerProxy.startActivity方法最终会调用到ActivityManagerService.startActivity()方法，先看看这几个类的关系：<br><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/ams_amp_amn_structure.png" alt="ams_amp_amn_structure"></p><h4 id="ActivityManagerNative、ActivityManagerProxy、ActivityManagerService"><a href="#ActivityManagerNative、ActivityManagerProxy、ActivityManagerService" class="headerlink" title="ActivityManagerNative、ActivityManagerProxy、ActivityManagerService"></a>ActivityManagerNative、ActivityManagerProxy、ActivityManagerService</h4><p>看了上图，知道了ActivityManagerNative、ActivityManagerProxy、ActivityManagerService这三个类的关系，接下来进入ActivityManagerService.startActivity()方法：<br><figure class="highlight java"><figcaption><span>ActivityManagerService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 调用ActivityStarter.startActivityMayWait()方法</span></span><br><span class="line">    <span class="keyword">return</span> mActivityStarter.startActivityMayWait(caller, -<span class="number">1</span>, callingPackage, intent,</span><br><span class="line">            resolvedType, <span class="keyword">null</span>, <span class="keyword">null</span>, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">            profilerInfo, <span class="keyword">null</span>, <span class="keyword">null</span>, bOptions, <span class="keyword">false</span>, userId, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AMS.startActivity()方法调用了startActivityAsUser()方法，随后进入ActivityStarter.startActivityMayWait()方法:<br><figure class="highlight java"><figcaption><span>ActivityStarter.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityMayWait</span><span class="params">(IApplicationThread caller, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">            String callingPackage, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">            ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config,</span></span></span><br><span class="line"><span class="function"><span class="params">            Bundle bOptions, <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">            IActivityContainer iContainer, TaskRecord inTask)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 解析activity，返回ActivityInfo对象</span></span><br><span class="line">    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">    aInfo, rInfo, voiceSession, voiceInteractor,</span><br><span class="line">    resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">    callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">    options, ignoreTargetSecurity, componentSpecified, outRecord, container,</span><br><span class="line">    inTask);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityLocked</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span></span></span><br><span class="line"><span class="function"><span class="params">            String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">            String callingPackage, <span class="keyword">int</span> realCallingPid, <span class="keyword">int</span> realCallingUid, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityOptions options, <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">boolean</span> componentSpecified,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,</span></span></span><br><span class="line"><span class="function"><span class="params">            TaskRecord inTask)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这一步有好几个错误码赋值，这里只拿出START_CLASS_NOT_FOUND这一个举例，因为这个是最常见的，即ActivityNotFoundException抛出的原因</span></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        err = ActivityManager.START_CLASS_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags,</span><br><span class="line">                <span class="keyword">true</span>, options, inTask);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 进入ActivityStack.java</span></span><br><span class="line">    mTargetStack.startActivityLocked(mStartActivity, newTask, mKeepCurTransition, mOptions);</span><br><span class="line">    <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 进入ActivityStackSupervisor，pause当前activity</span></span><br><span class="line">        mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class="line">                mOptions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>ActivityStarter.startActivityMayWait()方法会调用到startActivityLocked()方法，接着调用startActivityUnchecked()方法，该方法会先调用ActivityStack.startActivityLocked方法，接着调用ActivityStackSupervisor.resumeFocusedStackTopActivityLocked()方法，该方法最终回调到ActivityStack.startPausingLocked()方法来pause当前activity，来看看ActivityStack.startActivityLocked：</p><figure class="highlight java"><figcaption><span>ActivityStack.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startActivityLocked</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> newTask, <span class="keyword">boolean</span> keepCurTransition,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ensureActivitiesVisibleLocked(<span class="keyword">null</span>, <span class="number">0</span>, !PRESERVE_WINDOWS);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">ensureActivitiesVisibleLocked</span><span class="params">(ActivityRecord starting, <span class="keyword">int</span> configChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> preserveWindows)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (makeVisibleAndRestartIfNeeded(starting, configChanges, isTop,</span><br><span class="line">                                resumeNextActivity, r)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">makeVisibleAndRestartIfNeeded</span><span class="params">(ActivityRecord starting, <span class="keyword">int</span> configChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> isTop, <span class="keyword">boolean</span> andResume, ActivityRecord r)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 进入ActivityStackSupervisor.java</span></span><br><span class="line">    mStackSupervisor.startSpecificActivityLocked(r, andResume, <span class="keyword">false</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActivityStack.startActivityLocked()方法再经过内部两个方法的处理后，最终进入ActivitySupervisor.java类中：<br><figure class="highlight java"><figcaption><span>ActivityStackSupervisor.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">    ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">            r.info.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="keyword">true</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="string">"activity"</span>, r.intent.getComponent(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    app.thread.scheduleLaunchActivity(<span class="keyword">new</span> Intent(r.intent), r.appToken,</span><br><span class="line">                        System.identityHashCode(r), r.info, <span class="keyword">new</span> Configuration(mService.mConfiguration),</span><br><span class="line">                        <span class="keyword">new</span> Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage,</span><br><span class="line">                        task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,</span><br><span class="line">                        newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ActivityStackSupervisor.startSpecificActivityLocked()方法中先是判断了目标activity所在进程是否已经启动，若未启动则会先启动进程，这个流程在<a href="http://jackhuang.online/2018/12/19/AndroidApp%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/#more" target="_blank" rel="noopener">Android-App启动过程分析</a>中已经分析过了，此处略过，直接看进程已经启动的情况，会调用realStartActivityLocked()方法，</p><h4 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h4><p>接着进入ActivityThread.java中，scheduleLaunchActivity()方法中通过handler调用到handleLaunchActivity()方法：</p><figure class="highlight java"><figcaption><span>ActivityThread.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent, String reason)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// performLaunchActivity方法内部逐步回调activity的attach、onCreate、onStart方法</span></span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line">    <span class="keyword">if</span>(a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 该方法会调用performResumeActivity方法，内部会调用Activity.performResume方法，接着调用Instrumentation.callActivityOnResume()方法，回调了Activity的onResume生命周期方法</span></span><br><span class="line">        handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward,</span><br><span class="line">                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 至此，activity的onResume方法回调之后，页面已经展现在屏幕之中了</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">            ...</span><br><span class="line">            Window window = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.mPendingRemoveWindow != <span class="keyword">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">                window = r.mPendingRemoveWindow;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// activity的attach()方法会调用attachBaseContext()方法</span></span><br><span class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 回调Activity的onCreate()方法</span></span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                <span class="comment">// 调用activity.performStart()方法内部会调用Instrumentation.callActivityOnStart()方法回调Activity的onStart()方法</span></span><br><span class="line">                activity.performStart();</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>到这里，startActivity整个流程已经走完了，来看张图总结一下步骤：<br><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/startActivity_flow.png" alt="start_activity_flow"></p><p>由Activity A启动Activity B，两个Activity的生命周期调用顺序为：</p><ul><li>Activity A —-&gt; onPause()</li><li>Activity B —-&gt; attach()</li><li>Activity B —-&gt; onCreate()</li><li>Activity B —-&gt; onStart()</li><li>Activity B —-&gt; onResume()</li><li>Activity A —-&gt; onStop()</li><li>Activity A —-&gt; onDestory() (如果需要，即调用startActivity之后调用了finish())</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/huangzhengneng/ImageFactory/raw/master/blog/activity_launch_flow_cover.jpeg&quot; alt=&quot;activity_launcher_flow&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="source analysis" scheme="http://yoursite.com/tags/source-analysis/"/>
    
  </entry>
  
  <entry>
    <title>Android App启动过程分析</title>
    <link href="http://yoursite.com/2018/12/19/AndroidApp%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/12/19/AndroidApp启动过程分析/</id>
    <published>2018-12-19T08:18:10.000Z</published>
    <updated>2019-11-21T03:11:22.410Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/app_launcher_flow_cover.jpeg" alt="launcher-flow"></p><hr><a id="more"></a><h3 id="Android从Launcher开始分析app启动流程"><a href="#Android从Launcher开始分析app启动流程" class="headerlink" title="Android从Launcher开始分析app启动流程"></a>Android从Launcher开始分析app启动流程</h3><p><strong>先看看整个过程简要流程图</strong></p><p><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/app_launcher_flow.png" alt="app-launcher-flow"></p><p><strong>接下来开始逐步从源码角度分析该过程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：本文基于Android 7.1.0，api25源码分析</span><br></pre></td></tr></table></figure></p><h3 id="Launcher"><a href="#Launcher" class="headerlink" title="Launcher"></a>Launcher</h3><p>用户点击桌面图标，桌面即Launcher应用，从Android4.4之后开始使用Launcher3，在源码中找到Launcher3之后，其MainActivity就是Launcher.java，该Activity在onResume方法中调用了LauncherModel的startLoader方法加载所有的app：<br><figure class="highlight java"><figcaption><span>LauncherModel.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startLoader</span><span class="params">(<span class="keyword">int</span> synchronousBindPage)</span> </span>&#123;</span><br><span class="line">    startLoader(synchronousBindPage, LOADER_FLAG_NONE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startLoader</span><span class="params">(<span class="keyword">int</span> synchronousBindPage, <span class="keyword">int</span> loadFlags)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mLoaderTask = <span class="keyword">new</span> LoaderTask(mApp.getContext(), loadFlags);</span><br><span class="line">        <span class="keyword">if</span> (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE</span><br><span class="line">                &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded &amp;&amp; !mIsLoaderTaskRunning) &#123;</span><br><span class="line">            mLoaderTask.runBindSynchronousPage(synchronousBindPage);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// sWorkerThread是HandlerThread实例</span></span><br><span class="line">            sWorkerThread.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            sWorker.post(mLoaderTask);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>LauncherModel中调用了startLoader重载方法，开启了一个LoaderTask任务，LoaderTask是LauncherModel的内部类：<br><figure class="highlight java"><figcaption><span>LoaderTask.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LoaderTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        keep_running: &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 加载app</span></span><br><span class="line">            loadAndBindAllApps();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadAndBindAllApps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!mAllAppsLoaded) &#123;</span><br><span class="line">            loadAllApps();</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            onlyBindAllApps();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>LoaderTask中loadAllApps方法会调用ManagedProfileHeuristic类的processUserApps方法，解析所有的app，最后回调LauncherModel的addAndBindAddedWorkspaceItems方法，该方法会调用Launcher的bindAppsAdded方法：<br><figure class="highlight java"><figcaption><span>Launcher.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindAppsAdded</span><span class="params">(<span class="keyword">final</span> ArrayList&lt;Long&gt; newScreens,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> ArrayList&lt;ItemInfo&gt; addNotAnimated,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> ArrayList&lt;ItemInfo&gt; addAnimated,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> ArrayList&lt;AppInfo&gt; addedApps)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (addNotAnimated != <span class="keyword">null</span> &amp;&amp; !addNotAnimated.isEmpty()) &#123;</span><br><span class="line">        bindItems(addNotAnimated, <span class="number">0</span>,</span><br><span class="line">                addNotAnimated.size(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (addAnimated != <span class="keyword">null</span> &amp;&amp; !addAnimated.isEmpty()) &#123;</span><br><span class="line">        bindItems(addAnimated, <span class="number">0</span>,</span><br><span class="line">                addAnimated.size(), <span class="keyword">true</span>);</span><br><span class="line">    &#125;                       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindItems</span><span class="params">(<span class="keyword">final</span> ArrayList&lt;ItemInfo&gt; shortcuts, <span class="keyword">final</span> <span class="keyword">int</span> start, <span class="keyword">final</span> <span class="keyword">int</span> end,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">final</span> <span class="keyword">boolean</span> forceAnimateIcons)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (item.itemType) &#123;</span><br><span class="line">        <span class="keyword">case</span> LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span><br><span class="line">        <span class="keyword">case</span> LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span><br><span class="line">            ShortcutInfo info = (ShortcutInfo) item;</span><br><span class="line">            <span class="comment">// 创建桌面快捷图标</span></span><br><span class="line">            view = createShortcut(info);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">View <span class="title">createShortcut</span><span class="params">(ShortcutInfo info)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createShortcut((ViewGroup) mWorkspace.getChildAt(mWorkspace.getCurrentPage()), info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">createShortcut</span><span class="params">(ViewGroup parent, ShortcutInfo info)</span> </span>&#123;</span><br><span class="line">    BubbleTextView favorite = (BubbleTextView) mInflater.inflate(R.layout.app_icon,</span><br><span class="line">            parent, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 注册点击事件</span></span><br><span class="line">    favorite.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> favorite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    Object tag = v.getTag();</span><br><span class="line">    <span class="keyword">if</span> (tag <span class="keyword">instanceof</span> ShortcutInfo) &#123;</span><br><span class="line">        onClickAppShortcut(v);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到Launcher会为每个app在桌面创建一个BubbleTextView类型的shortcut，并且注册点击事件，调用onClickAppShortcut()方法，最终会调用到startAppShortcutOrInfoActivity方法：<br><figure class="highlight java"><figcaption><span>Launcher.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Thunk</span> <span class="function"><span class="keyword">void</span> <span class="title">startAppShortcutOrInfoActivity</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> success = startActivitySafely(v, intent, tag);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startActivitySafely</span><span class="params">(View v, Intent intent, Object tag)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        success = startActivity(v, intent, tag);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ActivityNotFoundException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>直到调用startActivitySafely方法，该方法内部调用Launcher的startActivity(View, Intent, Object)方法，接着调用Activity的startActivity(Intent,Bundle)方法，进入开启activity流程。<br>具体的开启Activity流程，之后会有单独的文章介绍，总之最后会执行到ActivityStackSupervisor的startSpecificActivityLocked方法：<br><figure class="highlight java"><figcaption><span>ActivityStackSupervisor.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">        ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">                r.info.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123; <span class="comment">// 目标activity所在进程已存在</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// 启动Activity</span></span><br><span class="line">                realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">               ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目标activity所在进程不存在，启动进程</span></span><br><span class="line">        mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="keyword">true</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="string">"activity"</span>, r.intent.getComponent(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>startSpecificActivityLocked方法会判断目标activity所在进程是否存在，如不存在，就会先开启进程。</p><hr><h3 id="开启app进程"><a href="#开启app进程" class="headerlink" title="开启app进程"></a>开启app进程</h3><p>由上一步能看见，当目标进程不存在时，会调用ActivityManagerService#startProcessLocked()方法启动进程：<br><figure class="highlight java"><figcaption><span>ActivityManagerService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">            String hostingType, String hostingNameStr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用重载方法startProcessLocked</span></span><br><span class="line">        startProcessLocked(app, hostingType, hostingNameStr, <span class="keyword">null</span> <span class="comment">/* abiOverride */</span>,</span><br><span class="line">                <span class="keyword">null</span> <span class="comment">/* entryPoint */</span>, <span class="keyword">null</span> <span class="comment">/* entryPointArgs */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">startProcessLocked</span><span class="params">(String processName, ApplicationInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags, String hostingType, ComponentName hostingName,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> allowWhileBooting, <span class="keyword">boolean</span> isolated, <span class="keyword">int</span> isolatedUid, <span class="keyword">boolean</span> keepIfLarge,</span></span></span><br><span class="line"><span class="function"><span class="params">            String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            ProcessRecord app;</span><br><span class="line">            <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// 根据进程名称和uid获取ProcessRecord</span></span><br><span class="line">                app = getProcessRecordLocked(processName, info.uid, keepIfLarge);</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(app == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 不存在就创建ProcessRecord</span></span><br><span class="line">                app = newProcessRecordLocked(info, processName, isolated, isolatedUid);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            startProcessLocked(</span><br><span class="line">                app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);</span><br><span class="line">            <span class="keyword">return</span> (app.pid != <span class="number">0</span>) ? app : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, String hostingType,</span></span></span><br><span class="line"><span class="function"><span class="params">            String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 调用Process.start方法开启进程</span></span><br><span class="line">            Process.ProcessStartResult startResult = Process.start(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, entryPointArgs);</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>以上AMS中三个重载方法，主要做两件事：</strong></p><ol><li>根据processName、uid获取ProcessRecord</li><li>调用Process.start()创建进程</li></ol><p>接下来看Process.start()实现：</p><figure class="highlight java"><figcaption><span>Process.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                debugFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                abi, instructionSet, appDataDir, zygoteArgs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ProcessStartResult <span class="title">startViaZygote</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String[] extraArgs)</span></span></span><br><span class="line"><span class="function">                                  <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 调用zygoteSendArgsAndGetResult()方法</span></span><br><span class="line">    <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法主要是通过Socket给zygote进程发送要创建的进程参数列表，然后</span></span><br><span class="line"><span class="comment">// zygote进程fork一个子进程，并返回pid</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ProcessStartResult result = <span class="keyword">new</span> ProcessStartResult();</span><br><span class="line">    result.pid = inputStream.readInt();</span><br><span class="line">    result.usingWrapper = inputStream.readBoolean();</span><br><span class="line">    <span class="keyword">if</span> (result.pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"fork() failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回pid</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上Process.java中主要是通过Socket发送开启进程需要的参数给Zygote进程，fork出app进程，其中有一个processClass字符串参数，它就是进程创建成功之后的进程入口，会调用该类的main函数，默认就是android.app.ActivityThread，因此ActivityThread的main函数，就是app进程的入口：</p><figure class="highlight java"><figcaption><span>ActivityThread.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    <span class="comment">// 调用attach函数，开始创建Application</span></span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// UI线程消息轮询器开始轮询UI线程的消息</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="comment">// 若轮训器意外终止，app进程将会抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 该IActivityManager对象，可从ActivityManagerNative的asInterface(IBinder)方法中看见返回的是ActivityManagerProxy对象</span></span><br><span class="line">        <span class="comment">// 调用ActivityManagerNative的内部类ActivityManagerProxy的attachApplication方法</span></span><br><span class="line">        mgr.attachApplication(mAppThread);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActivityThread的main方法会创建AcitivityThread对象，调用attach方法，并且开启UI线程消息轮询，attach方法中调用了ActivityManagerNative的内部类ActivityManagerProxy的attachApplication方法，该方法中通过binder调用了ActivityManagerService中的attachApplication(IApplicationThread)方法：</p><figure class="highlight java"><figcaption><span>ActivityManagerService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attachApplication</span><span class="params">(IApplicationThread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        attachApplicationLocked(thread, callingPid);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取创建的进程</span></span><br><span class="line">    ProcessRecord app = mPidsSelfLocked.get(pid);</span><br><span class="line">    <span class="comment">// 调用ActivityThread的bindApplication方法</span></span><br><span class="line">    thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,</span><br><span class="line">                    profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</span><br><span class="line">                    app.instrumentationUiAutomationConnection, testMode,</span><br><span class="line">                    mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                    isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                    <span class="keyword">new</span> Configuration(mConfiguration), app.compat,</span><br><span class="line">                    getCommonServicesLocked(app.isolated),</span><br><span class="line">                    mCoreSettingsObserver.getCoreSettingsLocked());</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AMS的attachApplicationLocked方法中，调用了ActivityThread的bindApplication方法，该方法中通过handler调用了ActivityThread的handleBindApplication方法：</p><figure class="highlight java"><figcaption><span>ActivityThread.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> ContextImpl appContext = ContextImpl.createAppContext(<span class="keyword">this</span>, data.info);</span><br><span class="line">    <span class="keyword">if</span> (ii != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ApplicationInfo instrApp = <span class="keyword">new</span> ApplicationInfo();</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> LoadedApk pi = getPackageInfo(instrApp, data.compatInfo,</span><br><span class="line">                appContext.getClassLoader(), <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">final</span> ContextImpl instrContext = ContextImpl.createAppContext(<span class="keyword">this</span>, pi);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ClassLoader cl = instrContext.getClassLoader();</span><br><span class="line">            mInstrumentation = (Instrumentation)</span><br><span class="line">                cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> ComponentName component = <span class="keyword">new</span> ComponentName(ii.packageName, ii.name);</span><br><span class="line">        mInstrumentation.init(<span class="keyword">this</span>, instrContext, appContext, component,</span><br><span class="line">                data.instrumentationWatcher, data.instrumentationUiAutomationConnection);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mInstrumentation = <span class="keyword">new</span> Instrumentation();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line">    ...</span><br><span class="line">    mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">    ...</span><br><span class="line">    mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上ActivityThread的handleBindApplication方法中，主要做以下事情：</p><ol><li>创建AppContext</li><li>创建Instrumentation对象</li><li>初始化Instrumentation</li><li>创建Application对象</li><li>回调Application的onCreate方法</li></ol><p>就这样，Application的onCreate方法就被回调了。</p><p>由此，创建app进程流程就完毕了，接下来看启动Activity</p><h3 id="启动SplashActivity"><a href="#启动SplashActivity" class="headerlink" title="启动SplashActivity"></a>启动SplashActivity</h3><p>回到ActivityManagerService中attachApplicationLocked方法，该方法调用了thread.bindApplication之后，调用了ActivityStackSupervisor的attachApplicationLocked方法：</p><figure class="highlight java"><figcaption><span>ActivityManagerService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,</span><br><span class="line">                    profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</span><br><span class="line">                    app.instrumentationUiAutomationConnection, testMode,</span><br><span class="line">                    mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                    isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                    <span class="keyword">new</span> Configuration(mConfiguration), app.compat,</span><br><span class="line">                    getCommonServicesLocked(app.isolated),</span><br><span class="line">                    mCoreSettingsObserver.getCoreSettingsLocked());</span><br><span class="line">            updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mStackSupervisor.attachApplicationLocked(app)) &#123;</span><br><span class="line">            didSomething = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>ActivityStackSupervisor.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(ProcessRecord app)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (realStartActivityLocked(hr, app, <span class="keyword">true</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            didSomething = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，调用realStartActivityLocked方法，启动App进程的SplashActivity，app正式启动。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>App从Launcher点击图标启动App整个流程，如文章开头简要图一样，主要步骤文字描述如下：</p><ol><li>用户点击Launcher中的app的shortcut</li><li>调用startActivity方法启动目标app的Main页面(即AndroidManifest.xml中带有android.intent.action.MAIN的activity)</li><li>判断目标app所在进程是否存在，不存在就启动，存在直接启动activity</li><li>创建并启动目标app进程</li><li>创建Application，回调Application生命周期方法</li><li>启动MainActivity(即AndroidManifest.xml中带有android.intent.action.MAIN的activity)</li><li>App展现在屏幕之中</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/huangzhengneng/ImageFactory/raw/master/blog/app_launcher_flow_cover.jpeg&quot; alt=&quot;launcher-flow&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="source analysis" scheme="http://yoursite.com/tags/source-analysis/"/>
    
  </entry>
  
  <entry>
    <title>leetcode算法题记录篇(1)</title>
    <link href="http://yoursite.com/2018/09/13/leetcode%E7%AE%97%E6%B3%95%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AF%87-1/"/>
    <id>http://yoursite.com/2018/09/13/leetcode算法题记录篇-1/</id>
    <published>2018-09-13T07:17:36.000Z</published>
    <updated>2019-11-21T03:11:22.411Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/algorithms_cover.jpeg" alt="leetcode"></p><hr><a id="more"></a><h3 id="第一题：两数之和"><a href="#第一题：两数之和" class="headerlink" title="第一题：两数之和"></a>第一题：两数之和</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p><p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></span><br><span class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>遍历目标数组，将每次遍历的value和index存入map</li><li>若map中存在目标值减去当前遍历的值时，说明这两个数相加等于目标值</li><li>使用map.containsKey()使这一步的时间复杂度降低到O(1)</li></ul><h4 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(nums[i]) &amp;&amp; target == nums[i] * <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 相同的值除非是target刚好等于这个值的2倍，其它都没有影响</span></span><br><span class="line">            result[<span class="number">0</span>] = map.get(nums[i]);</span><br><span class="line">            result[<span class="number">1</span>] = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(target - nums[i]) &amp;&amp; map.get(target - nums[i]) != i) &#123;</span><br><span class="line">            result[<span class="number">0</span>] = map.get(target - nums[i]);</span><br><span class="line">            result[<span class="number">1</span>] = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>], <span class="number">2</span></span><br><span class="line">输出：</span><br><span class="line">[<span class="number">0</span>, <span class="number">6</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p></blockquote><hr><h3 id="第二题：两数相加"><a href="#第二题：两数相加" class="headerlink" title="第二题：两数相加"></a>第二题：两数相加</h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">输出：<span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">原因：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807</span></span><br></pre></td></tr></table></figure><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>按顺序把2个链表对应位数相加</li><li>遇到相加大于等于10的进一位到下个节点</li><li>返回结果</li></ul><h4 id="java实现-1"><a href="#java实现-1" class="headerlink" title="java实现"></a>java实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode sumNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode tmp = sumNode;</span><br><span class="line">    <span class="keyword">boolean</span> isNeedAdd = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> val1 = (l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val), val2 = (l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val);</span><br><span class="line">        sumNode.val = val1 + val2 + (isNeedAdd ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        isNeedAdd = sumNode.val &gt;= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (sumNode.val &gt;= <span class="number">10</span>) &#123; <span class="comment">// 过10进1</span></span><br><span class="line">            sumNode.val = sumNode.val % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        l1 = (l1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : l1.next);</span><br><span class="line">        l2 = (l2 == <span class="keyword">null</span> ? <span class="keyword">null</span> : l2.next);</span><br><span class="line">        <span class="keyword">if</span> (!(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isNeedAdd) &#123;</span><br><span class="line">                ListNode last = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">                sumNode.next = last;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode node = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        sumNode.next = node;</span><br><span class="line">        sumNode = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">输入的数是：<span class="number">2</span>-<span class="number">4</span>-<span class="number">3</span>, 和: <span class="number">5</span>-<span class="number">6</span>-<span class="number">4</span></span><br><span class="line">输出的数是： <span class="number">7</span>-<span class="number">0</span>-<span class="number">8</span></span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p></blockquote><hr><h3 id="第三题：无重复字符的最长子串"><a href="#第三题：无重复字符的最长子串" class="headerlink" title="第三题：无重复字符的最长子串"></a>第三题：无重复字符的最长子串</h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>给定一个字符串，找出不含有重复字符的最长子串的长度。</p><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 无重复字符的最长子串是 &quot;abc&quot;，其长度为 3。</span><br></pre></td></tr></table></figure><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 无重复字符的最长子串是 &quot;b&quot;，其长度为 1。</span><br></pre></td></tr></table></figure><h5 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 无重复字符的最长子串是 &quot;wke&quot;，其长度为 3。</span><br><span class="line">     请注意，答案必须是一个子串，&quot;pwke&quot; 是一个子序列 而不是子串。</span><br></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ul><li>1.暴力法，直接遍历每一个元素，时间复杂度为O(n3)</li><li>2.滑动窗口(hashSet(On –&gt; O2n)，hashMap(On)，ASCII字符集(On))</li></ul><blockquote><p>第一感觉是暴力法，后面看到leetcode<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/" target="_blank" rel="noopener">阅读解答</a>得出了滑动窗口的解法</p></blockquote><h4 id="java实现-2"><a href="#java实现-2" class="headerlink" title="java实现"></a>java实现</h4><h5 id="采用ASCII字符集数组代替Set、Map"><a href="#采用ASCII字符集数组代替Set、Map" class="headerlink" title="采用ASCII字符集数组代替Set、Map"></a>采用ASCII字符集数组代替Set、Map</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, len = str.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>,i = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        i = Math.max(index[str.charAt(j)], i);</span><br><span class="line">        ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">        index[str.charAt(j)] = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">输入：asdfergfsadsa</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n)<br>空间复杂度：O(m)  m是字符集的大小</p></blockquote><h5 id="HashSet解法"><a href="#HashSet解法" class="headerlink" title="HashSet解法"></a>HashSet解法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; length &amp;&amp; j &lt; length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!set.contains(String.valueOf(s.charAt(j)))) &#123;</span><br><span class="line">            set.add(String.valueOf(s.charAt(j++)));</span><br><span class="line">            result = Math.max(result, j - i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set.remove(String.valueOf(s.charAt(i++)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">输入：asdfergfsadsa</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n)<br>空间复杂度：O(min(m,n))</p></blockquote><h5 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (allUnique(s, i, j)) ans = Math.max(ans, j - i);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allUnique</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        Character ch = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (set.contains(ch)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        set.add(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">输入：asdfergfsadsa</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n3)<br>空间复杂度：O(min(m,n))</p></blockquote><hr><h3 id="第四题：求两个有序数组的中位数"><a href="#第四题：求两个有序数组的中位数" class="headerlink" title="第四题：求两个有序数组的中位数"></a>第四题：求两个有序数组的中位数</h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。<br>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。<br>你可以假设 nums1 和 nums2 不会同时为空。</p><h5 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a>示例 1</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [1, 3] nums2 = [2]</span><br><span class="line">输出: 2.0 </span><br><span class="line">解释: 重排序之后，中位数是2</span><br></pre></td></tr></table></figure><h5 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2"></a>示例 2</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [1, 2] nums2 = [3, 4]</span><br><span class="line">输出: (2 + 3)/2 = 2.5</span><br><span class="line">解释: 重排序之后，中位数是(2 + 3)/2</span><br></pre></td></tr></table></figure><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><h5 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h5><p>暴力法： 1. 合并两个有序数组 2. m + n 如果是奇数，取中间一个，如果是偶数，取中间两个</p><p>java实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmptyArray(arr1) &amp;&amp; isEmptyArray(arr2)) &#123; <span class="comment">// 临界判断</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并操作</span></span><br><span class="line">    <span class="keyword">int</span>[] array = merge(arr1, arr2);</span><br><span class="line">    <span class="keyword">int</span> lenght = array.length;</span><br><span class="line">    <span class="keyword">if</span> (lenght % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (array[lenght / <span class="number">2</span> - <span class="number">1</span>] + array[lenght / <span class="number">2</span>]) / <span class="number">2.0f</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> array[lenght / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEmptyArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2) &#123;</span><br><span class="line">    <span class="keyword">int</span> lenght = (arr1 == <span class="keyword">null</span> ? <span class="number">0</span> : arr1.length) + (arr2 == <span class="keyword">null</span> ? <span class="number">0</span> : arr2.length);</span><br><span class="line">    <span class="keyword">if</span> (isEmptyArray(arr1)) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isEmptyArray(arr2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[lenght];</span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index1 &lt;= arr1.length - <span class="number">1</span> &amp;&amp; index2 &lt;= arr2.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr1[index1] &lt;= arr2[index2]) &#123;</span><br><span class="line">            result[index++] = arr1[index1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[index++] = arr2[index2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index1 == arr1.length) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index2, len = arr2.length; i &lt;= len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            result[index++] = arr2[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index2 == arr2.length) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index1, len = arr1.length; i &lt;= len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            result[index++] = arr1[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(max(m, n))<br>空间复杂度：O(m+n)</p></blockquote><h5 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h5><ol><li>记住两个数组长度和，按这个次数去循环</li><li>比较两个数组当前循环到的元素大小，小的往前走一步，下一次循环</li><li>当有一个数组循环完毕，直接循环另一个数组</li><li>如果长度是奇数，循环到 (m+n)/2 就返回这个数</li><li>如果长度是偶数，循环到 (m+n)/2 就返回 当前循环的这个数和上一个数 相加除以2</li></ol><p>java实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmptyArray(arr1)) &#123;</span><br><span class="line">        <span class="comment">// 取第二个数组的中位数</span></span><br><span class="line">        <span class="keyword">int</span> lenght = arr2.length;</span><br><span class="line">        <span class="keyword">return</span> lenght % <span class="number">2</span> == <span class="number">0</span> ? (arr2[lenght / <span class="number">2</span> - <span class="number">1</span>] + arr2[lenght / <span class="number">2</span>]) / <span class="number">2.0f</span> : arr2[lenght / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isEmptyArray(arr2)) &#123;</span><br><span class="line">        <span class="comment">// 取第二个数组的中位数</span></span><br><span class="line">        <span class="keyword">int</span> lenght = arr1.length;</span><br><span class="line">        <span class="keyword">return</span> lenght % <span class="number">2</span> == <span class="number">0</span> ? (arr1[lenght / <span class="number">2</span> - <span class="number">1</span>] + arr1[lenght / <span class="number">2</span>]) / <span class="number">2.0f</span> : arr1[lenght / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lenght = arr1.length + arr2.length;</span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; lenght) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index1 == arr1.length) &#123;</span><br><span class="line">            tmp = arr2[index2++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index2 == arr2.length) &#123;</span><br><span class="line">            tmp = arr1[index1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr1[index1] &lt;= arr2[index2]) &#123;</span><br><span class="line">                tmp = arr1[index1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp = arr2[index2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == lenght / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> lenght % <span class="number">2</span> == <span class="number">1</span> ? (<span class="keyword">float</span>) tmp : (tmp + pre) / <span class="number">2.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        pre = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(m+n)<br>空间复杂度：O(1)</p></blockquote><h5 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h5><p>在第一个数组中寻找一个下标i，求出在第二个数组中对应的下标j，使得 <strong>i + j = m - i + n - j</strong><br>即 <strong>arr1[0~i-1].lenght + arr2[0~j-1].lenght == arr1[i~m].lenght + arr2[j~n].lenght</strong><br>这样当 <strong>arr1[i-1] &lt;= arr2[j]</strong><br>并且 <strong>arr1[i] &gt;= arr2[j-1]</strong> 时，<br>如果m+n是奇数，就返回 <strong>max(arr1[i-1], arr2[j-1])</strong><br>如果m+n是偶数，就返回 <strong>max(arr1[i-1], arr2[j-1]) / 2.0 + min(arr1[i], arr2[j]) / 2.0</strong></p><p>java实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = arr1.length;</span><br><span class="line">    <span class="keyword">int</span> n = arr2.length;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; n) &#123; <span class="comment">// 确保m&lt;=n</span></span><br><span class="line">        <span class="keyword">int</span>[] tmp = arr1;</span><br><span class="line">        arr1 = arr2;</span><br><span class="line">        arr2 = tmp;</span><br><span class="line">        <span class="keyword">int</span> len = m;</span><br><span class="line">        m = n;</span><br><span class="line">        n = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> iMin = <span class="number">0</span>, iMax = m, halfLen = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (iMin &lt;= iMax) &#123; <span class="comment">// 每一次循环，查找i值，查找范围缩小一半  因此循环 log2为底，min(m, n)的对数 遍</span></span><br><span class="line">        <span class="keyword">int</span> i = (iMin + iMax) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> j = halfLen - i; <span class="comment">// arr2的中位数</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; iMax &amp;&amp; arr1[i] &lt; arr2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            iMin = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; iMin &amp;&amp; arr2[j] &lt; arr1[i - <span class="number">1</span>])&#123;</span><br><span class="line">            iMax = i - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> maxLeft = i == <span class="number">0</span> ? arr2[j - <span class="number">1</span>] : (j == <span class="number">0</span> ? arr1[i - <span class="number">1</span>] : Math.max(arr1[i - <span class="number">1</span>], arr2[j - <span class="number">1</span>]));</span><br><span class="line">            <span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> maxLeft;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> minRight = i == m ? arr2[j] : (j == n ? arr1[i] : Math.min(arr1[i], arr2[j]));</span><br><span class="line">            <span class="keyword">return</span> (maxLeft + minRight) / <span class="number">2.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(log(min(m, n)))<br>空间复杂度：O(1)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/huangzhengneng/ImageFactory/raw/master/blog/algorithms_cover.jpeg&quot; alt=&quot;leetcode&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="algorithms" scheme="http://yoursite.com/categories/algorithms/"/>
    
    
      <category term="algorithms" scheme="http://yoursite.com/tags/algorithms/"/>
    
      <category term="notes" scheme="http://yoursite.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>SQLite基本命令操作</title>
    <link href="http://yoursite.com/2018/09/12/SQLite%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/09/12/SQLite基本命令操作/</id>
    <published>2018-09-12T13:46:30.000Z</published>
    <updated>2019-11-21T03:11:22.411Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/cover.jpg" alt="cover"></p><hr><a id="more"></a><h3 id="SQLite3基本命令"><a href="#SQLite3基本命令" class="headerlink" title="SQLite3基本命令"></a>SQLite3基本命令</h3><h4 id="进入sqlite3交互模式"><a href="#进入sqlite3交互模式" class="headerlink" title="进入sqlite3交互模式"></a><center>进入sqlite3交互模式</center></h4><p><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/sqlite3_command_1.jpg" alt="进入sqlite3交互模式-1"><br><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/sqlite3_command_2.jpg" alt="进入sqlite3交互模式-2"></p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.　sqlite3.exe [dbname]　打开sqlite3的交互模式，[并创建数据库]。</span><br><span class="line">2.　open dbname 若未创建数据，可以创建数据库，若己创建则打开。</span><br><span class="line">3.　.databases显示当前打开的数据库文件</span><br><span class="line">4.　.exit 退出交互模式。</span><br><span class="line">5.　.help,列出命令的提示信息，可供于查阅。</span><br></pre></td></tr></table></figure><h4 id="创建销毁表"><a href="#创建销毁表" class="headerlink" title="创建销毁表"></a><center>创建销毁表</center></h4><p><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/sqlite3_command_3.jpg" alt="创建销毁表"></p><h5 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. .open mydb 打开要创建表的那个数据库。</span><br><span class="line">2.　create  table  &lt;table_name&gt;  (field1  type1, field2  type2,…);　建表语句。</span><br><span class="line">3.　.tables 查看当前数据库下所有的表。</span><br><span class="line">4.　.schema [tbname] 查看表结构(主要看列信息)。</span><br><span class="line">5.　drop table &lt;table_name&gt;; 销毁表的语句。</span><br></pre></td></tr></table></figure><h4 id="插入与查询"><a href="#插入与查询" class="headerlink" title="插入与查询"></a><center>插入与查询</center></h4><p><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/sqlite3_command_4.jpg" alt="插入与查询"></p><h5 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.　.tables 插入数据之前先确定，所要插入表的存在。</span><br><span class="line">2.　insert  into  &lt;table_name&gt;  values (value1, value2,…);向表中添加新记录</span><br><span class="line">3.　select  filed1,field2···  from  &lt;table_name&gt;;查询表中某些字段的记录。</span><br><span class="line">4.　select  *  from  &lt;table_name&gt;;查询表中所有字段的记录。</span><br><span class="line">5.　.header on 显示字段名称。</span><br><span class="line">6.　.mode column 以列模式显示字段的记录。默认是list模式</span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a><center>排序</center></h4><p><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/sqlite3_command_5.jpg" alt="排序"></p><h5 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">order by field desc|asc 此子句，可以用于表达排序，desc 表示降序，asc表示升序。</span><br></pre></td></tr></table></figure><h4 id="修改与删除记录"><a href="#修改与删除记录" class="headerlink" title="修改与删除记录"></a><center>修改与删除记录</center></h4><p><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/sqlite3_command_6.jpg" alt="修改与删除记录"></p><h5 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.　update　&lt;table_name&gt;  set  &lt;field1=value1&gt;,&lt;fied2=value2&gt;··where  &lt;expression&gt;;  </span><br><span class="line">　　　　更新表中记录。若没有where子句，则会全部修改。</span><br><span class="line">2.　delete  from  &lt;table_name&gt;  where  &lt;expression&gt;;  若没有where子句，则会删全表内容，但不同于drop。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/huangzhengneng/ImageFactory/raw/master/blog/cover.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="sqlite" scheme="http://yoursite.com/tags/sqlite/"/>
    
  </entry>
  
  <entry>
    <title>20-30岁黄金十年</title>
    <link href="http://yoursite.com/2018/09/12/20-30%E5%B2%81%E9%BB%84%E9%87%91%E5%8D%81%E5%B9%B4/"/>
    <id>http://yoursite.com/2018/09/12/20-30岁黄金十年/</id>
    <published>2018-09-12T13:25:31.000Z</published>
    <updated>2019-11-21T03:11:22.409Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/huangzhengneng/ImageFactory/raw/master/blog/life.jpg" alt="life"></p><hr><a id="more"></a><h3 id="黄金十年应该养成的好习惯"><a href="#黄金十年应该养成的好习惯" class="headerlink" title="黄金十年应该养成的好习惯"></a>黄金十年应该养成的好习惯</h3><h5 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h5><p>养成坚持锻炼的好习惯，并且把它变成日常生活，不可或缺的一部分，年轻生活，很容易把身体素质筑基起来，但也有很多人，是在这个阶段，无端的耗损了大量的精气。大凡事业上成绩辉煌的，精力充沛，异常旺盛的，占了多数。</p><h5 id="爱好"><a href="#爱好" class="headerlink" title="爱好"></a>爱好</h5><p>去掉一个又一个的坏习惯，养成几个陪伴终生的好技能。如烟，酒，以前沾的，现在可以不碰；早睡早起，不熬夜；学一门厨艺，减少外出用餐次数，这是非常实用的；积累一门运动爱好，游泳，登山，球类，健身等，并且持之以恒。</p><p><strong>以上两点是保持人生细水长流，水流深处自然静，能坚持到最后终点的精髓。</strong></p><h5 id="大量的阅读"><a href="#大量的阅读" class="headerlink" title="大量的阅读"></a>大量的阅读</h5><p>多读无用之书，你会更加丰富、充盈、睿智，体验和感受他人的价值观，看透大千世界的人生百态，并且形成自己对人世和社会的看法。<br>比如你吃过的五谷杂粮，过后忘记了，但它变成了你身体的一部分，坚强了你的骨骼，充盈了五脏六腑。</p><h5 id="多尝试"><a href="#多尝试" class="headerlink" title="多尝试"></a>多尝试</h5><p>但明显就无法积累经验的，要放弃；不要怕失败，可改行，变换不同行业，但30岁左右，要基本上上却确定，今后人生所从事的职业；</p><h5 id="找一位贴心的配偶"><a href="#找一位贴心的配偶" class="headerlink" title="找一位贴心的配偶"></a>找一位贴心的配偶</h5><p>能在困难中陪伴你度过难关，在精神上于你合拍，不离不弃，忠诚专一。</p><h5 id="先成家后立业"><a href="#先成家后立业" class="headerlink" title="先成家后立业"></a>先成家后立业</h5><p>30岁之前或稍稍晚些时间，建立家庭，完成结婚生子人生两件至关重要的大事；</p><h5 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h5><p>如果家境财力丰厚，不必过早出来工作，先去国外游学几年，或行万里路，再读万卷书，最后才是打拼事业。</p><h5 id="眼界"><a href="#眼界" class="headerlink" title="眼界"></a>眼界</h5><p>很多人工作，都是不得已而为之，除开获取微薄的薪水，用时间换取金钱外，既不能增加自己的见识，也不能开阔自己的阅历，这是一个困境。但如自身有更好的条件，一定先要去“开眼界”，看看不同的国家风土人情，文化习俗等，能大大开拓将来的事业思路。</p><h5 id="接受挫折"><a href="#接受挫折" class="headerlink" title="接受挫折"></a>接受挫折</h5><p>三十之前“挫败“一次不可怕，很有可能是一次及其宝贵的经验，正在茁茂成长的大树，狂风暴雨是吹不到的，根系会越扎越深。反之，中年遇到失败，损失过于惨重。</p><h5 id="做减法"><a href="#做减法" class="headerlink" title="做减法"></a>做减法</h5><p>学会做减法，小智唯谋，大智知止。</p><h5 id="希望"><a href="#希望" class="headerlink" title="希望"></a>希望</h5><p>无论任何时候，活着就是一切，就有希望。</p><ul><li>31岁，你活过了黄家驹；</li><li>32岁，你活过了李小龙；</li><li>33岁，你活过了亚历山大；</li><li>34岁，你活过了蔡锷；</li><li>35岁，你活过了陈百强；</li><li>36岁，你活过了英国诗人拜伦。</li></ul><hr><p><strong>能健健康康的过完一辈子，你就已经赢了很多人。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/huangzhengneng/ImageFactory/raw/master/blog/life.jpg&quot; alt=&quot;life&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="随想" scheme="http://yoursite.com/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="人生" scheme="http://yoursite.com/tags/%E4%BA%BA%E7%94%9F/"/>
    
      <category term="理想" scheme="http://yoursite.com/tags/%E7%90%86%E6%83%B3/"/>
    
  </entry>
  
</feed>
